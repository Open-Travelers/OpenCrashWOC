union variptr_u buffer_start;
union variptr_u buffer_tmpstart;
union variptr_u *buffer_tmpend;
union variptr_u *buffer_tmpptr;
union variptr_u *buffer_endptr;
union variptr_u *buffer_freeptr;
struct nugscn_s *gscene;
s32 scene_version;
struct numemfile_s memfiles[20];
struct gsc_context_s gsc_load_context;
int readfile_base;
extern s32 gscn_dbg;

extern s32 nutex_alloc_cnt;
extern s32 tex_allocmax;


#define ALIGN_ADDRESS(addr, al) (((s32)addr + (al-1)) & ~(al-1))
#define LOWERCASE(in) ((in >= 0x41 && in <= 0x5A) ? in + 0x20 : in)
#define SQUARE(in) ((in) * (in))
#define SQUARE_SUM(x, y, z) (SQUARE(x) + SQUARE(y) + SQUARE(z))
#define MAX(a, b) ((a < b) ? b : a)
// Square euclidean distance
#define DIST_FROM_POINT(a, b, c, p) ((SQUARE(a - p.x) + SQUARE(b - p.y) + SQUARE(c - p.z)))

void* NuMemFileAddr(int fh)
{
  return memfiles[fh + -0x400].curr;
}

//MATCH
static inline void* NuGScnBufferAllocAligned(union variptr_u *ptr, int size, int alignment) {
    u32 mem;
    mem = ALIGN_ADDRESS(ptr->voidptr, alignment);
    
    if ((mem + size) < (int)buffer_tmpptr.intaddr) {
        ptr->u32 = (unsigned int*)(mem + size);
        return (void*)mem;
    }
    else {
        NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0x181)("NuGScnBufferAllocAligned failed, scene ptr overrun. ");
        return 0;
    }
}

//98%
struct nugscn_s* NuGScnRead(union variptr_u *ptr, union variptr_u *buffend, char *filename)
{
    struct nugscn_s *rv;
    void *mem; //temp?
    
    buffer_freeptr = ptr;
    buffer_start = *ptr;
    buffer_endptr = buffend;
    if (buffer_tmpstart.voidptr != 0) {
        buffer_tmpptr = buffer_tmpend;
    } else {
        buffer_tmpptr = buffend;
    }
        
    readfile_base = (int)NuGScnBufferAllocAligned(buffer_freeptr, 0, 0x80);
    mem = (void*)readfile_base;
    // do {
    gsc_load_context.size = NuFileLoadBuffer(filename, mem, (s32)buffend - ptr->intaddr);
    gsc_load_context.mem = mem;
    gsc_load_context.freeptr = ptr;
    gsc_load_context.endptr = buffend;
    gsc_load_context.file = filename;
    // } while(0);
    
    if (gsc_load_context.size == 0) {
        rv = NULL;
    }
    else {
        rv = NuGScnLoadFix();
    }
    return rv;
}

//MATCH
void NuGScnUpdate(struct nugscn_s *scn, float dt) {
    int cnt;
    struct nuinstance_s * i;
    struct nuanimdata_s * animdata;
    float ltime;
    struct nuinstanim_s * instanim;
    struct nuanimtime_s atime;
    struct numtx_s animtx;

    cnt = scn->numinstance;
    i = &scn->instances[cnt];
    while ( cnt != 0 ) {
        i--;
        cnt--;
        if ((gscn_dbg != 0) && (gscn_dbg != cnt)) {
            continue;
        }
        if (((i->flags.visible) & i->flags.visitest) == 0) { 
            continue;
        } 
        instanim = i->anim;
        if (i->anim == NULL) {
            continue;
        }
        if (scn->instanimdata == NULL) {
            continue;
        }
        if (scn->instanimdata[i->anim->anim_ix] == NULL) {
            continue;
        }               
        animdata = scn->instanimdata[i->anim->anim_ix];
        if (instanim->playing) {
            instanim->ltime += dt * instanim->tfactor;
            if ((instanim->waiting) && (instanim->ltime >= instanim->tfirst)) {
                instanim->waiting = 0; 
                instanim->ltime -=  instanim->tfirst - 1.0f;
            }
            if (instanim->waiting == 0) {
                 if (instanim->ltime >= (animdata->time + instanim->tinterval)) {
                    if (instanim->repeating != 0) {
                        while (instanim->ltime >= (animdata->time + instanim->tinterval)) {
                               if (instanim->oscillate != 0) {
                                   instanim->backwards = !instanim->backwards;
                               }
                             instanim->ltime = (instanim->ltime + 1.0f) - (animdata->time + instanim->tinterval);
                        } 
                            ltime = instanim->ltime;
                    }
                    else {
                         instanim->playing = 0;
                        ltime = instanim->ltime = animdata->time;
                    }
                }
                else if (instanim->ltime > animdata->time) {
                    ltime = animdata->time;
                }
                else {
                    ltime = instanim->ltime;
                }
                    
                if (instanim->backwards != 0) {
                    ltime = (animdata->time + 1.0f) - ltime;
                }
            }
        }
        else {
            ltime = instanim->ltime;
        }
        NuAnimDataCalcTime(animdata, ltime, &atime);
        NuAnimCurveSetApplyToMatrix(*animdata->chunks[atime.chunk]->animcurvesets, &atime, &animtx);
        memcpy(&instanim->mtx, &animtx, sizeof(struct numtx_s));
        NuMtxTranslate(&instanim->mtx, (struct nuvec_s*)&i->mtx._30);
    }
}

//MATCH
void NuCvtGeoFixup(struct nucolourref_s* ref, int offset) {
        while(ref->count != 0)
        {
            ref->addr = (int)((char*)offset + (int)ref->addr);
            ref = (char*)ref + ((ref->count * 8) + 8);
        }
}

//98%
static void ReadObjSet(int fh) {
    int sp14;
    int sp18;
    int sp1C;
    int temp_s0_2;
    int temp_s5;
    int temp_s6;
    int temp_s6_2;
    int temp_v0_5;
    void* var_a0;
    struct nuvec_s zero;
    struct nufaceongeom_s *fgeom;
    struct nugobj_s* gobj;
    int i;
    int j;
    int k;
    int l;
    struct nugeom_s *geo;
    struct nufaceongeom_s *fgeo;
    int numgobj;

    memset(&zero, 0, sizeof(struct nuvec_s));
    NuDebugMsgProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xb59)("Reading Objset set...");
    numgobj = NuFileReadInt(fh);
    sp18 = NuFileReadInt(fh);
    gscene->gobjs = NuGScnBufferAllocAligned(buffer_freeptr, numgobj * sizeof(struct nugobj_s*), 0x4);
    memset(gscene->gobjs, 0, numgobj * 4);
    gscene->numgobj = numgobj;
    
    for (i = 0; i < numgobj; i++) {
        sp14 = NuFileReadInt(fh);
        NuFileReadInt(fh);
        NuFileReadInt(fh);
        NuFileReadInt(fh);
        
        gscene->gobjs[i] = gobj = NuGScnBufferAllocAligned(buffer_freeptr, sp14 * sizeof(struct nugobj_s), 0x4);
        
        memset(gobj, 0, sp14 * sizeof(struct nugobj_s));
        gobj->flags = sp14;
        for (j = 0; j < sp14; j++){
            gobj->type = NuFileReadInt(fh);
            switch (gobj->type) {
                case 0:
                    temp_s6 = NuFileReadInt(fh);
                    NuFileRead(fh, &gobj->origin, sizeof(struct nuvec_s));
                    var_a0 = NuGScnBufferAllocAligned(buffer_freeptr, temp_s6 * sizeof(struct nugeom_s), 0x4);
                    geo = (struct nugeom_s *)var_a0;
                    memset(geo, 0, temp_s6 * sizeof(struct nugeom_s));
                    
                    sp1C = NuFileReadInt(fh);
                    NuFileReadInt(fh);
                    NuFileReadInt(fh);
                    gobj->geom = geo;
                    memset(geo, 0, temp_s6 * sizeof(struct nugeom_s));
                    
                    for (k = 0; k < temp_s6; k++) {
                        
                        if (k != (temp_s6 - 1)) {
                            geo->next = geo + 1;
                        }
                        
                        NuFileReadInt(fh);
                        temp_s0_2 = NuFileReadInt(fh);
                        geo->mtl = (struct numtl_s* )gscene->mtls[NuFileReadInt(fh)];
                        NuMemFileSeek(fh, temp_s0_2, 1);
                        temp_v0_5 = NuFileReadInt(fh);
                        if (temp_v0_5 & 0xF) {
                            NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xb92)("invalid qwc");
                        }

                        // bitfields man
                        if ((geo->mtl->attrib.ot) == 1) {
                            geo->tristream = NuMemFileAddr(fh);
                            // ?????
                            for (l = 0; l < geo->tristream->count; l++) {
                                int t = (int)(&((struct nuvutri_s*)geo->tristream)[l]);
                                int t1 = (int)(&((struct nuvutri_s*)geo->tristream)[l+1]);
                                *(int*)(t + 0x14) = (int)(t1 + 0x10);
                            }
                        } else {
                            struct _sceDmaTag *tag;
                            
                            geo->dmastream = NuMemFileAddr(fh);
                            if ((int)geo->dmastream & 0x7F) {
                                NuDebugMsgProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xb9d)("Geom DMASTREAM not 128 byte aligned");  
                            }

                            tag = geo->dmastream; 
                            while (tag->id == 0x20) {
                                tag = tag->next = (struct _sceDmaTag*)((int)tag->next + (int)tag);
                            }
                        }
                        NuMemFileSeek(fh, temp_v0_5, 1);
                        geo++;
                    }
                    gobj->colourref_size = sp1C;
                    break;
                case 1:
                    temp_s6_2 = NuFileReadInt(fh);
                    NuFileReadInt(fh);
                    NuFileReadInt(fh);
                    gobj->origin = zero;
                    fgeo = fgeom = NuGScnBufferAllocAligned(buffer_freeptr, temp_s6_2 * sizeof(struct nufaceongeom_s), 0x4);
                    memset(fgeom, 0, temp_s6_2 * sizeof(struct nufaceongeom_s));
                    gobj->faceon_geom = fgeo;
                    
                    for (k = 0; k < temp_s6_2; k++) {
                        
                        if (k != (temp_s6_2 - 1)) {
                            fgeo->next = fgeo + 1;
                        }
                        
                        fgeo->mtl = gscene->mtls[NuFileReadInt(fh)];
                        fgeo->faceon_type = NuFileReadInt(fh);
                        fgeo->faceon_radius = NuFileReadFloat(fh);
                        temp_s5 = NuFileReadInt(fh);
                        fgeo->dmastream = NuMemFileAddr(fh);
                        NuMemFileSeek(fh, temp_s5, 1);
                        fgeo++;
                    }
                    break;
                default:
                    NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xbcf)("Unknown geom type");
                    break;
            }
            NuFileRead(fh, &gobj->min, 0xC);
            NuFileRead(fh, &gobj->max, 0xC);
            NuFileReadInt(fh);
            NuFileReadInt(fh);
            
            gobj->cntr.x = (gobj->min.x + gobj->max.x) * 0.5f;
            gobj->cntr.y = (gobj->min.y + gobj->max.y) * 0.5f;
            gobj->cntr.z = (gobj->min.z + gobj->max.z) * 0.5f;


            gobj->r2 =     SQUARE_SUM(gobj->min.x, gobj->min.y, gobj->min.z);
            gobj->r2 = MAX(SQUARE_SUM(gobj->max.x, gobj->min.y, gobj->min.z), gobj->r2);
            gobj->r2 = MAX(SQUARE_SUM(gobj->min.x, gobj->max.y, gobj->min.z), gobj->r2);
            gobj->r2 = MAX(SQUARE_SUM(gobj->max.x, gobj->max.y, gobj->min.z), gobj->r2);
            gobj->r2 = MAX(SQUARE_SUM(gobj->min.x, gobj->min.y, gobj->max.z), gobj->r2);
            gobj->r2 = MAX(SQUARE_SUM(gobj->max.x, gobj->min.y, gobj->max.z), gobj->r2);
            gobj->r2 = MAX(SQUARE_SUM(gobj->min.x, gobj->max.y, gobj->max.z), gobj->r2);
            gobj->r2 = MAX(SQUARE_SUM(gobj->max.x, gobj->max.y, gobj->max.z), gobj->r2);
            
            gobj->r = sqrt(gobj->r);
            
            gobj->cntr_r2 =     DIST_FROM_POINT(gobj->min.x, gobj->min.y, gobj->min.z, gobj->cntr);
            gobj->cntr_r2 = MAX(DIST_FROM_POINT(gobj->max.x, gobj->min.y, gobj->min.z, gobj->cntr), gobj->cntr_r2);
            gobj->cntr_r2 = MAX(DIST_FROM_POINT(gobj->min.x, gobj->max.y, gobj->min.z, gobj->cntr), gobj->cntr_r2);
            gobj->cntr_r2 = MAX(DIST_FROM_POINT(gobj->max.x, gobj->max.y, gobj->min.z, gobj->cntr), gobj->cntr_r2);
            gobj->cntr_r2 = MAX(DIST_FROM_POINT(gobj->min.x, gobj->min.y, gobj->max.z, gobj->cntr), gobj->cntr_r2);
            gobj->cntr_r2 = MAX(DIST_FROM_POINT(gobj->max.x, gobj->min.y, gobj->max.z, gobj->cntr), gobj->cntr_r2);
            gobj->cntr_r2 = MAX(DIST_FROM_POINT(gobj->min.x, gobj->max.y, gobj->max.z, gobj->cntr), gobj->cntr_r2);
            gobj->cntr_r2 = MAX(DIST_FROM_POINT(gobj->max.x, gobj->max.y, gobj->max.z, gobj->cntr), gobj->cntr_r2);
            
            gobj->cntr_r = sqrt(gobj->cntr_r2);
            
            gobj++;
        }
        
        gscene->gobjs[i]->colourref = 0;
        gscene->gobjs[i]->focolourref = 0;
        if (sp18 == 1) {
            gscene->gobjs[i]->colourref_size = NuFileReadInt(fh);
            NuFileReadInt(fh);
            NuFileReadInt(fh);
            NuFileReadInt(fh);
            if (gscene->gobjs[i]->colourref_size != 0) {
                gscene->gobjs[i]->colourref = NuMemFileAddr(fh);
                NuMemFileSeek(fh, gscene->gobjs[i]->colourref_size, 1);
                NuCvtGeoFixup(gscene->gobjs[i]->colourref, readfile_base);
            }
        }
    }
}

static inline void ReadInstSet(s32 fh) {
    int i;
    
    gscene->numinstance = NuFileReadInt(fh);
    NuFileReadInt(fh);
    gscene->instances = NuMemFileAddr(fh);
    NuMemFileSeek(fh, gscene->numinstance * sizeof(struct nuinstance_s), 1);
    
    for (i = 0; i < gscene->numinstance; i++) {
        gscene->instances[i].flags.visitest = 1;
    }
}

static inline void ReadNameTable(s32 fh) {
    int i;
    int size;
    
    size = NuFileReadInt(fh);
    gscene->nametable = NuMemFileAddr(fh);
    NuMemFileSeek(fh, size, 1);
    
    for (i = 0; i < size; i++){
        gscene->nametable[i] = LOWERCASE(gscene->nametable[i]);
    }
}

static inline void ReadSpecialSet(s32 fh) {
    int i;
    struct nuspecial_s *sp;
    struct nuinstance_s *ins;
    
    gscene->numspecial = NuFileReadInt(fh);
    NuFileReadInt(fh);
    gscene->specials = NuMemFileAddr(fh);
    ins = NuMemFileAddr(fh); // check this
    NuMemFileSeek(fh, gscene->numspecial * sizeof(struct nuspecial_s), 1);
    
    sp = gscene->specials;
    for (i = 0; i < gscene->numspecial; i++) {
        sp->mtx = gscene->instances[ins->objid].mtx;
        sp->instance = &gscene->instances[ins->objid];
        sp->name =  (s32)gscene->nametable + *(s32*)&ins->flags; // check this?
        sp->flags.ext = 0;
        sp++;
        ins++;
    }
}

// Dunno about the name, it was commented as INSTANIMBLOCK
static inline void ReadInstAnim(s32 fh) {
    int i;
    struct nuinstanim_s* anim;
    struct nuinstanim_s* p_anim;
    
    NuFileReadInt(fh);
    NuFileReadInt(fh);
    gscene->instanimblock = NuMemFileAddr(fh);
    
    anim = gscene->instanimblock;
    if (gscene->instanimblock != NULL) {
        for (i = 0; i < gscene->numinstance; i++)  {
            if (gscene->instances[i].anim != NULL){
                gscene->instances[i].anim = anim++;
                // gscene->instances[i].anim->mtx = anim->mtx;
                // needs to be explicit? Probably inline memes
                memcpy(gscene->instances[i].anim, &gscene->instances[i], 0x40);
            }
        }
    }
}

static inline void ReadInstId(s32 fh) {
        gscene->numinstanceixs = NuFileReadInt(fh);
         NuFileReadInt(fh);
         gscene->instanceixs = NuMemFileAddr(fh);
}

//MATCH
void ReadTextureSet(int fh) {
    int* faddr;
    int temp_s3;
    int temp_s4;
    int off1;
    int i;

    NuDebugMsgProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xa8d)("Reading type 2 texture set header...");
    temp_s4 = NuFileReadInt(fh);
    NuFileReadInt(fh);
    gscene->tids = NuGScnBufferAllocAligned(buffer_freeptr, temp_s4 * 4, 4);
    memset(gscene->tids, 0, temp_s4 * 4);
    gscene->numtid = temp_s4;
    for(i = 0; i < temp_s4; i++) {
        temp_s3 = NuFileReadInt(fh);
        off1 = NuFileReadInt(fh);
        if (off1 == 0) {
            NuFileReadInt(fh);
            NuFileReadInt(fh);
        } else {
            NuFileSeek(fh, off1, 1);
        }
        faddr = NuMemFileAddr(fh);
        NuMemFileSeek(fh, temp_s3, 1);
        gscene->tids[i] = NuTexCreateNative(faddr);
    }
}

//98%
void ReadAnimationLibrary(int fh) {
    int numanim;
    int i;
    int ncurves;
    int nKeys;
    int nChunks;
    struct nugscn_s *pnVar2;
    struct nuanimdata_s *animdata;
    struct nuanimdatachunk_s *chunk;
    struct nuanimcurveset_s *curveset;
    struct nuanimcurve_s *curve;
    
    numanim = NuFileReadInt(fh);
    NuFileReadInt(fh);
    gscene->instanimdata = NuMemFileAddr(fh);
    pnVar2 = gscene;
    
    for (i = 0; i < numanim; i++)
    {
        ASSIGN_IF_SET(pnVar2->instanimdata[i], (struct nuanimdata_s *)((int)&pnVar2->instanimdata[i] + (int)pnVar2->instanimdata[i]));
        animdata = pnVar2->instanimdata[i];
        if (animdata != NULL) {
            ASSIGN_IF_SET(animdata->chunks, (struct nuanimdatachunk_s **)((int)&animdata->chunks + (int)animdata->chunks));
            
            for(nChunks = 0; nChunks < animdata->nchunks; nChunks++)
            {
                ASSIGN_IF_SET(animdata->chunks[nChunks], (struct nuanimdatachunk_s *)((int)&animdata->chunks[nChunks] + (int)animdata->chunks[nChunks]));
                chunk = animdata->chunks[nChunks];
                ASSIGN_IF_SET(chunk->animcurvesets, (struct nuanimcurveset_s **)((int)&chunk->animcurvesets + (int)(chunk->animcurvesets)));
                
                for (nKeys = 0; nKeys < chunk->numnodes; nKeys++)
                {
                    ASSIGN_IF_SET(chunk->animcurvesets[nKeys], (struct nuanimcurveset_s *)((int)&chunk->animcurvesets[nKeys] + (int)chunk->animcurvesets[nKeys]));
                    curveset = chunk->animcurvesets[nKeys];
                    ASSIGN_IF_SET(curveset->constants, (float *)((int)(&curveset->constants) + (int)curveset->constants));
                    ASSIGN_IF_SET(curveset->set, (struct nuanimcurve_s **)((int)(&curveset->set) + (int)curveset->set));
                    
                    for (ncurves = 0; ncurves < curveset->ncurves; ncurves++)
                    {
                        if (curveset->set[ncurves] == NULL) {
                            continue;
                        }
                        curveset->set[ncurves] = (struct nuanimcurve_s *)((int)&curveset->set[ncurves] + (int)curveset->set[ncurves]);
                        curve = curveset->set[ncurves];
                        ASSIGN_IF_SET(curve->animkeys, (struct nuanimkey_s *)((int)(&curve->animkeys) + (int)curve->animkeys));
                    }
                }
            }
        }
    }
}

//MATCH
struct nugscn_s * NuGScnLoadFix(void)
{
    void *start;
    char* filename;
    int filesize;
    int fh;
    int fileversion;
    int filemagic;
    union variptr_u *freeptr;
    struct nugscn_s *scene;
    
    gscene = NULL;
    timeUserReset();
    freeptr = gsc_load_context.freeptr;
    filename = gsc_load_context.gscfile;
    filesize = gsc_load_context.memsize;
    
    if (filesize <= 0) {
        return gscene;
    }

    start = NuGScnBufferAllocAligned(buffer_freeptr, filesize, 0x10);
    
    if (start == NULL) {
        NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xefd)("GSC File too large, \"%s\" ", filename);
    }

    gscene = NuGScnBufferAllocAligned(buffer_freeptr, sizeof(struct nugscn_s), 0x04);
    if (gscene != NULL) {
        memset(gscene, 0, sizeof(struct nugscn_s));
        fh = NuMemFileOpen(start, filesize, NUFILE_READ);
        if (fh != 0) {
            NuFileBeginBlkRead(fh, 0x3032554e); // NU20
            fileversion = NuFileReadInt(fh);
            NuFileReadInt(fh);
            if (fileversion < scene_version) {
                NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xf09)("GSC File out of date - need newer \"%s\" file", filename);
            }
            if (scene_version < fileversion) {
                NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xf0c)("Loader out of date - need newer 3D");
            }
            
            while (filemagic = NuFileBeginBlkRead(fh, 0)) {
                DbgBlkType(filemagic);
                switch (filemagic) {
                    // TST0
                    // TST2
                    case 0x30545354:
                    case 0x32545354:
                        ReadTextureSet(fh);
                        break;
                    // MS00
                    // MS02
                    case 0x3030534d:
                    case 0x3230534d:
                        ReadMaterialSet(fh);
                        break;
                    // OBJ0
                    case 0x304a424f:
                        ReadObjSet(fh);
                        break;
                    // INST
                    case 0x54534e49:
                        ReadInstSet(fh);
                        break;
                    // NTBL
                    case 0x4c42544e:
                        ReadNameTable(fh);
                        break;
                    // SPEC
                    case 0x43455053:
                        ReadSpecialSet(fh);
                        break;
                    // SST0
                    case 0x30545353:
                        ReadSplineSet(fh);
                        break;
                    // IABL
                    case 0x4c424149:
                        ReadInstAnim(fh);
                        break;
                    // ALIB
                    case 0x42494c41:
                        ReadAnimationLibrary(fh);
                        break;
                    // INID
                    case 0x44494e49:
                        gscene->numinstanceixs = NuFileReadInt(fh);
                        NuFileReadInt(fh);
                        gscene->instanceixs = NuMemFileAddr(fh);
                        break;
                    // MS00
                    case 0x30534154:
                        ReadTexAnimSet(fh);
                        break;                        
                }
                NuFileEndBlkRead(fh);
            }
            NuFileEndBlkRead(fh);
            NuMemFileClose(fh);
        }
        
        (*freeptr).u32 = (unsigned int*)ALIGN_ADDRESS((*freeptr).u32, 0x10U);
        NuRndrSplineSearch(gscene);
    }
    return gscene;
}

struct nuhghhdr_s { // 0x94
	/* 0x00 */ s32 filesize;
	/* 0x04 */ s32 version;
	/* 0x08 */ s32 numtxtrs;
	/* 0x0c */ s32 txtrs;
	/* 0x10 */ s32 nummtls;
	/* 0x14 */ s32 mtls;
	/* 0x18 */ s32 num_joints;
	/* 0x1c */ s32 joints;
	/* 0x20 */ s32 t;
	/* 0x24 */ s32 inv_wt;
	/* 0x28 */ s32 num_joint_ixs;
	/* 0x2c */ s32 joint_ixs;
	/* 0x30 */ s32 string_table;
	/* 0x34 */ s32 string_table_size;
	/* 0x38 */ s32 num_poi_ixs;
	/* 0x3c */ s32 poi_ixs;
	/* 0x40 */ s32 num_points_of_interest;
	/* 0x44 */ s32 points_of_interest;
	/* 0x48 */ s32 num_layers;
	/* 0x4c */ s32 layers;
	/* 0x50 */ s32 shadow_data;
	/* 0x54 */ float sphere_radius;
	/* 0x58 */ float sphere_yoff;
	/* 0x5c */ struct nuvec_s min;
	/* 0x68 */ struct nuvec_s max;
	/* 0x74 */ float cylinder_yoff;
	/* 0x78 */ float cylinder_height;
	/* 0x7c */ float cylinder_radius;
	/* 0x80 */ s32 collision_data;
	/* 0x84 */ float tbrdist;
	/* 0x88 */ s32 numtexanims;
	/* 0x8c */ s32 texanims;
	/* 0x90 */ s32 display_scene;
};

//MATCH
static inline void NuGHGFixupGobj(union variptr_u start, int fgoffset, struct NUHGOBJ_s* hgo) {
    struct nufgobj_s* fgobj = (struct nufgobj_s*)fgoffset;
    struct nufgeomps2_s* fgeom;
    
    while (fgobj) {
        if (fgobj->geom) {
            fgobj->geom += (int)start.voidptr;
            fgeom = (struct nufgeomps2_s*)fgobj->geom;
            while (fgeom) {
                fgeom->mtl_id = (int)hgo->mtls[fgeom->mtl_id];
                
                if (fgeom->dmastream != NULL) {
                    fgeom->dmastream += (int)start.voidptr;
                }
                
                if (fgeom->skindma != 0) {
                    fgeom->skindma += (int)start.voidptr;
                    NuCvtSknInstFix((void*)fgeom->skindma);
                }
                
                if (fgeom->next != NULL) {
                    fgeom->next += (int)start.voidptr;
                    fgeom = (struct nufgeomps2_s*)fgeom->next;
                } else {
                    fgeom = NULL;
                }
            }
        }
        
        if (fgobj->next_gobj != 0) {
            fgobj->next_gobj += (int)start.voidptr;
            fgobj = (struct nufgobj_s*)fgobj->next_gobj;
        } else {
            fgobj = 0;
        }
    }
}

//93% WIP
struct NUHGOBJ_s* NuGHGRead(union variptr_u* buff, char* name) {
    union variptr_u mem;
    union variptr_u ptr;
    int check;
    int* piVar25;
    struct NUCOLLISIONDATA_s* chdr;
    struct nutexanim_s* txanm;
    struct NUSHADOWDATA_s* shad;
    struct NUSHADOWMESH_s* smesh;
    int iVar33;
    int iVar8;
    struct nuhghhdr_s* hdr;
    struct NUHGOBJ_s* hgo;
    struct NULAYERDATA_s* flayers;

    struct NuGobj** ppNVar37;

    //hgo = NULL;
    // mem.intaddr = ALIGN_ADDRESS(buff->voidptr, 0x10U);
    buff->voidptr = (void*)ALIGN_ADDRESS(buff->voidptr, 0x10U);
    // local_b0 = (union variptr_u *)mem.intaddr;
    // hdr = (struct NUHGOBJ_s *)local_b0;
    check = NuFileLoadBuffer(name, buff->voidptr, 0x7fffffff);
    hdr = buff->voidptr;
    if (check > 0) {
        if (ghg_version > hdr->version)
            NuErrorProlog("..\\nu2.ps2\\nu3d\\nuhgobj.c", 0x61a)(
                "GHG file is out of date - needs to be reconverted (FILE VER:%d SYS VER:%d)", hdr->version, ghg_version
            );
        if (hdr->version > ghg_version)
            NuErrorProlog("..\\nu2.ps2\\nu3d\\nuhgobj.c", 0x61c)(
                "GHG loader is out of date - need newer 3d system (FILE VER:%d SYS VER:%d)", hdr->version, ghg_version
            );

        NuDebugMsgProlog("..\\nu2.ps2\\nu3d\\nuhgobj.c", 0x61f)("Reading %s", name);
        hgo = (struct NUHGOBJ_s*)ALIGN_ADDRESS((*(int*)buff->voidptr + (int)buff->voidptr), 0x10U);
        buff->voidptr = (void*)(hgo + 1);
        memset(hgo, 0, 0x84);
        hgo->loadtype = 1;
        if (hdr->txtrs != 0) {
            hgo->tids = (short*)((int)mem.s16 + hdr->txtrs);
            hgo->numtid = hdr->numtxtrs;
            piVar25 = (int*)((int)mem.voidptr + hdr->txtrs);
            for (iVar8 = 0; iVar8 < hgo->numtid; iVar8++) {
                hgo->tids[iVar8] = NuTexCreateNative((short*)((int)mem.voidptr + piVar25[iVar8]));
            }
        }

        if (hdr->mtls != NULL) {
            hgo->mtls = (struct numtl_s**)((int)mem.voidptr + (int)hdr->mtls);
            hgo->nummtl = hdr->nummtls;
            for (iVar8 = 0; iVar8 < hgo->nummtl; iVar8++) {
                hgo->mtls[iVar8] = (struct numtl_s*)((int)mem.voidptr + (int)hgo->mtls[iVar8]);
                if (hgo->mtls[iVar8]->tid != 0) {
                    hgo->mtls[iVar8]->tid = (int)hgo->tids[hgo->mtls[iVar8]->tid - 1];
                }
                NuDisableVBlank();
                NuMtlAdd(hgo->mtls[iVar8]);
                if ((*NuMtlReadEvent)(hgo->mtls[iVar8]) == 0) {
                    NuMtlUpdate(hgo->mtls[iVar8]);
                }
                NuEnableVBlank();
            }
        }

        hgo->tbrdist = hdr->tbrdist;
        hgo->string_table = mem.s8 + (int)hdr->string_table;
        hgo->string_table_size = hdr->string_table_size;
        hgo->num_joints = (int)hdr->num_joints & 0xFF; // check this field
        hgo->joints = (struct NUJOINTDATA_s*)((int)mem.voidptr + (int)hdr->joints);
        hgo->T = (struct numtx_s*)((int)mem.mtx44 + (int)hdr->t);
        hgo->INV_WT = (struct numtx_s*)((int)mem.mtx44 + (int)hdr->inv_wt);
        hgo->num_joint_ixs = hdr->num_joint_ixs;
        hgo->joint_ixs = mem.u8 + (int)hdr->joint_ixs;

        for (iVar8 = 0; iVar8 < hgo->num_joints; iVar8++) {
            if (hgo->joints[iVar8].name != 0) {
                hgo->joints[iVar8].name += (int)mem.voidptr;
            }
        }

        // check this field
        if (hdr->num_poi_ixs != 0) {
            hgo->num_poi_ixs = hdr->num_poi_ixs;
            hgo->poi_ixs = mem.u8 + (int)hdr->poi_ixs;
        }

        // check this field
        if (hdr->num_points_of_interest != 0) {
            hgo->num_points_of_interest = hdr->num_points_of_interest;
            // check this field
            hgo->points_of_interest = (struct NUPOINTOFINTEREST_s*)((int)mem.voidptr + *(int*)&hdr->points_of_interest);

            for (iVar8 = 0; iVar8 < hgo->num_points_of_interest; iVar8++) {
                if (hgo->points_of_interest[iVar8].name != 0) {
                    hgo->points_of_interest[iVar8].name += (int)mem.voidptr;
                }
            }
        }

        // check this field
        flayers = (struct NULAYERDATA_s*)((int)mem.voidptr + *(int*)&hdr->layers);
        hgo->layers = flayers;
        hgo->num_layers = hdr->num_layers;
        for (iVar8 = 0; iVar8 < hgo->num_layers; iVar8++, flayers++) {
            if (flayers->name != NULL) {
                flayers->name += (int)mem.s8;
            }
            if (flayers->gobjs != NULL) {
                flayers->gobjs = (struct NuGobj**)((int)flayers->gobjs + (int)mem.voidptr);
                ppNVar37 = flayers->gobjs;
                for (iVar33 = 0; iVar33 < hgo->num_joints; iVar33++) {
                    piVar25 = (int*)(ppNVar37[iVar33]);
                    if (piVar25 != 0) {
                        NuGHGFixupGobj(mem, (int)piVar25, hgo);
                    }
                }
            }

            if (flayers->skin_gobj != 0) {
                flayers->skin_gobj = (struct NuGobj*)((int)&flayers->skin_gobj->sysnext + (int)mem.voidptr);
                NuGHGFixupGobj(mem, (int)flayers->skin_gobj, hgo);
            }

            if (flayers->blend_gobjs != NULL) {
                flayers->blend_gobjs = (struct NuGobj**)((int)flayers->blend_gobjs + (int)mem.voidptr);
                ppNVar37 = flayers->blend_gobjs;
                for (iVar33 = 0; iVar33 < hgo->num_joints; iVar33++) {
                    piVar25 = (int*)(ppNVar37[iVar33]);
                    if (piVar25 != 0) {
                        NuGHGFixupGobj(mem, (int)piVar25, hgo);
                    }
                }
            }

            if (flayers->blend_skin_gobj != NULL) {
                flayers->blend_skin_gobj = (struct NuGobj*)((int)&flayers->blend_skin_gobj->sysnext + (int)mem.voidptr);
                NuGHGFixupGobj(mem, (int)flayers->blend_skin_gobj, hgo);
            }
        }

        hgo->sphere_radius = hdr->sphere_radius;
        hgo->sphere_yoff = hdr->sphere_yoff;
        hgo->min = hdr->min;
        hgo->max = hdr->max;
        hgo->cylinder_yoff = hdr->cylinder_yoff;
        hgo->cylinder_height = hdr->cylinder_height;
        hgo->cylinder_radius = hdr->cylinder_radius;
        hgo->collision_data = 0;

        if (hdr->collision_data != 0) {
            chdr = (struct NUCOLLISIONDATA_s*)(hdr->collision_data + (int)mem.voidptr);
            hgo->collision_data = chdr;
            chdr->hdrs = (struct NUCOLLISIONHDR_s*)((int)&chdr->hdrs->type + (int)mem.voidptr);
            for (iVar8 = 0; iVar8 < chdr->nitems; iVar8++) {
                chdr->hdrs[iVar8].data += (int)mem.voidptr;
            }
        }
        if (hdr->numtexanims != 0) {
        hgo->numtexanims = hdr->numtexanims;
        hgo->texanims = (struct nutexanim_s*)((int)mem.voidptr + (int)hdr->texanims);

        
            for (iVar33 = 0; iVar33 < hgo->numtexanims; iVar33++) {
                txanm = &hgo->texanims[iVar33];
                txanm->prev = NULL;
                txanm->tids = (short*)((int)txanm->tids + (mem.intaddr << 1));
                // txanm->tids = (int)mem.voidptr + txanm->tids;
                txanm->succ = NULL;

                for (iVar8 = 0; iVar8 < txanm->numtids; iVar8++) {
                    txanm->tids[iVar8] = hgo->tids[txanm->tids[iVar8]];
                }

                txanm->mtl = hgo->mtls[(int)txanm->mtl];
                txanm->ntaname = txanm->ntaname + (int)mem.s8;
                txanm->scriptname = txanm->scriptname + (int)mem.s8;
                ptr.voidptr = (void*)ALIGN_ADDRESS(ptr.voidptr, 0x10U);
                txanm->env = NuTexAnimEnvCreate(&ptr, txanm->mtl, txanm->tids, NuTexAnimProgFind(txanm->scriptname));
            }

        for (iVar8 = 0; iVar8 < hgo->numtexanims - 1; iVar8++) {
            hgo->texanims[iVar8].succ = &hgo->texanims[iVar8] + 1;
            hgo->texanims[iVar8 + 1].prev = &hgo->texanims[iVar8];
        }
        NuTexAnimAddList(hgo->texanims);
}
        hgo->shadow_data = NULL;

        if (hdr->shadow_data != 0) {
            hgo->shadow_data = (struct NUSHADOWDATA_s*)(hdr->shadow_data + (int)mem.voidptr);
            for (shad = hgo->shadow_data; shad->joint != 0xff; shad++) {

                if (shad->nellipsoids != 0) {
                    shad->ellipsoids = (struct NUELLIPSOID_s*)((int)shad->ellipsoids + (int)mem.voidptr);
                }

                if (shad->ncylinders != 0) {
                    shad->cylinders = (struct NUCYLINDER_s*)((int)shad->cylinders + (int)mem.intaddr);
                }

                if (shad->nshadow_meshes != 0) {
                    shad->shadow_meshes = (struct NUSHADOWMESH_s*)((int)shad->shadow_meshes + (int)mem.voidptr);
                    smesh = shad->shadow_meshes;
                    for (iVar8 = 0; iVar8 < shad->nshadow_meshes; iVar8++) {
                        smesh[iVar8].verts = (struct nuvec_s4_s*)((int)smesh[iVar8].verts + mem.intaddr);
                        smesh[iVar8].normals = (struct nuvec_s4_s*)((int)smesh[iVar8].normals + mem.intaddr);
                    }
                }
            }
        }
        buff->voidptr = (void*)ALIGN_ADDRESS(buff->voidptr, 0x10U);
        NuDebugMsgProlog("..\\nu2.ps2\\nu3d\\nuhgobj.c", 0x709)(
            "Read %s Used %d bytes", name, (int)buff->intaddr - mem.intaddr
        );
        buff->intaddr = mem.intaddr;
    }
    return hgo;
}


//85.65%

struct nuparamtest_s
{
    s16 unk0;
    u16 unk2;
    s16 unk4;
    s16 unk6;
    u16 unk8;
    u16 unka;
    u8  unkc;
    u8  unkd;
    u8  unke;
    u8  unkf;
    s32 unk10;
    s32 unk14;
    s32 unk18;
    s32 unk1c;
    s16 unk20;
};

struct ps2tex_s { // 0xb0
	/* 0x00 */ struct ps2tex_s *succ;
	/* 0x04 */ struct ps2tex_s *prev;
	/* 0x08 */ short unsigned int lowaddr;
	/* 0x0a */ short unsigned int highaddr;
	/* 0x0c */ short unsigned int req;
	/* 0x0e:0 */ short unsigned int housed : 1;
	/* 0x10 */ short unsigned int p2w;
	/* 0x12 */ short unsigned int p2h;
	/* 0x14 */ struct _sceDmaTag *dt_load[7];
	/* 0x30 */ unsigned int loadsize[7];
	/* 0x4c */ unsigned int offset[7];
	/* 0x68 */ short unsigned int loadaddr[7];
	/* 0x76 */ short unsigned int loadwidth[7];
	/* 0x84 */ short unsigned int bltwidth[7];
	/* 0x92 */ unsigned char nummm;
	/* 0x93 */ unsigned char psm;
	/* 0x94 */ unsigned char bltpsm;
	/* 0x95 */ unsigned char tcc;
	/* 0x96 */ unsigned char texa;
	/* 0x97 */ unsigned char tfx;
	/* 0x98 */ struct sceDmaTag *clut_load;
	/* 0x9c */ struct sceDmaTag *clut_alt;
	/* 0xa0 */ short unsigned int clut_addr;
	/* 0xa2 */ short unsigned int clut_width;
	/* 0xa4 */ short unsigned int clut_psm;
	/* 0xa6 */ short unsigned int clut_offset;
	/* 0xa8 */ short unsigned int clut_loadsize;
	/* 0xac */ unsigned int tmpaddr;
};

struct nutex_s { // 0x1c
	/* 0x00 */ enum nutextype_e type;
	/* 0x04 */ s32 width;
	/* 0x08 */ s32 height;
	/* 0x0c */ s32 mmcnt;
	/* 0x10 */ void *bits;
	/* 0x14 */ s32 *pal;
};

struct nusystex_s { // 0xe0
	/* 0x00 */ struct nutex_s tex;
	/* 0x18 */ short int ref;
	/* 0x1a:0 */ short int used : 1;
	/* 0x1a:1 */ short int xdef : 1;
	/* 0x1a:1 */ short int xdef1;
	/* 0x20 */ struct ps2tex_s ps2tex;
    s32 pad[4];
};


struct nutexanimf_s { // 0x20
	/* 0x00 */ struct nutexanim_s* *succ;
	/* 0x04 */ struct nutexanim_s* *prev;
	/* 0x08 */ s32 tids;
	/* 0x0c */ short int numtids;
	/* 0x0e:0 */ short int dynalloc : 1;
	/* 0x10 */ s32 mtl;
	/* 0x14 */ struct nutexanimenv_s* *env;
	/* 0x18 */ s32 ntaname;
	/* 0x1c */ s32 scriptname;
};

// Size: 0x14, DWARF: 0x9A56
struct NULAYERDATA_s
{
    char* name; // Offset: 0x0, DWARF: 0x9A78
    struct NuGobj** gobjs; // Offset: 0x4, DWARF: 0x9AA2
    struct NuGobj* skin_gobj; // Offset: 0x8, DWARF: 0x9AD0
    struct NuGobj** blend_gobjs; // Offset: 0xC, DWARF: 0x9B01
    struct NuGobj* blend_skin_gobj; // Offset: 0x10, DWARF: 0x9B35
};

struct nuflayerdata_s { // 0x14
	/* 0x00 */ int name;
	/* 0x04 */ int gobjs;
	/* 0x08 */ int skin_gobj;
	/* 0x0c */ int blend_gobjs;
	/* 0x10 */ int blend_skin_gobj;
};

// Size: 0x50, DWARF: 0x9B70
struct NUPOINTOFINTEREST_s
{
    struct numtx_s offset; // Offset: 0x0, DWARF: 0x9B98
    char* name; // Offset: 0x40, DWARF: 0x9BC3
    unsigned char parent_joint_ix; // Offset: 0x44, DWARF: 0x9BED
    unsigned char pad[11]; // Offset: 0x45, DWARF: 0x9C1F
};

enum Coltype
{
    NUCOLLISIONSPHERETYPE = 1
};


// Size: 0x8, DWARF: 0xB0C4
struct NUCOLLISIONHDR_s
{
    enum Coltype type;
    void* data;
};

// Size: 0x8, DWARF: 0x9DBE
struct NUCOLLISIONDATA_s
{
    u32 nitems; // Offset: 0x0, DWARF: 0x9DE4
    struct NUCOLLISIONHDR_s* hdrs; // Offset: 0x4, DWARF: 0x9E0D
};

// Size: 0x30, DWARF: 0xAE76
struct NUELLIPSOID_s
{
    struct nuvec_s centre; // Offset: 0x0, DWARF: 0xAE98
    struct nuvec_s y_axis; // Offset: 0xC, DWARF: 0xAEC3
    struct nuvec_s x_axis; // Offset: 0x18, DWARF: 0xAEEE
    struct nuvec_s z_axis; // Offset: 0x24, DWARF: 0xAF19
};

// Size: 0x40, DWARF: 0xAF48
struct NUCYLINDER_s
{
    struct nuvec_s centre; // Offset: 0x0, DWARF: 0xAF69
    struct nuvec_s y_axis; // Offset: 0xC, DWARF: 0xAF94
    struct nuvec_s4_s x_axis; // Offset: 0x18, DWARF: 0xAFBF
    struct nuvec_s4_s z_axis; // Offset: 0x28, DWARF: 0xAFEA
    char pad[8]; // Offset: 0x38, DWARF: 0xB015
};

// Size: 0x8, DWARF: 0xB041
struct NUSHADOWMESH_s
{
    struct nuvec_s4_s* normals; // Offset: 0x0, DWARF: 0xB064
    struct nuvec_s4_s* verts; // Offset: 0x4, DWARF: 0xB093
};

// Size: 0x10, DWARF: 0x9C4B
struct NUSHADOWDATA_s
{
    struct NUELLIPSOID_s* ellipsoids; // Offset: 0x0, DWARF: 0x9C6E
    struct NUCYLINDER_s* cylinders; // Offset: 0x4, DWARF: 0x9CA0
    struct NUSHADOWMESH_s* shadow_meshes; // Offset: 0x8, DWARF: 0x9CD1
    unsigned char nellipsoids; // Offset: 0xC, DWARF: 0x9D06
    unsigned char ncylinders; // Offset: 0xD, DWARF: 0x9D34
    unsigned char nshadow_meshes; // Offset: 0xE, DWARF: 0x9D61
    unsigned char joint; // Offset: 0xF, DWARF: 0x9D92
};


struct nufgeomps2_s { // 0x10
	/* 0x0 */ int next;
	/* 0x4 */ int mtl_id;
	/* 0x8 */ int dmastream;
	/* 0xc */ int skindma;
};

union NUGOBJEX_s { // 0xc
	/* 0x0 */ struct nuvec_s origin;
	/* 0x0 */ struct { // 0xc
		/* 0x0 */ float dist;
		/* 0x4 */ float dist2;
		/* 0x8:0 */ short unsigned int centre_at_origin : 1;
		/* 0x9 */ char pad[2];
	} lod;
};

struct nugobj_s { // 0x6c
	/* 0x00 */ struct nugobj_s *sysnext;
	/* 0x04 */ struct nugobj_s *syslast;
	/* 0x08 */ enum gobjtype_s type;
	/* 0x0c */ struct NuGeom *geom;
	/* 0x10 */ struct nufaceongeom_s *faceon_geom;
	/* 0x14 */ float r;
	/* 0x18 */ float r2;
	/* 0x1c */ struct nuvec_s min;
	/* 0x28 */ struct nuvec_s max;
	/* 0x34 */ struct nuvec_s cntr;
	/* 0x40 */ float cntr_r;
	/* 0x44 */ float cntr_r2;
	/* 0x48 */ s32 flags;
	/* 0x4c */ struct nugobj_s *next_gobj;
	/* 0x50 */ struct nuvec_s origin;
	/* 0x5c */ struct nucolourref_s *colourref;
	/* 0x60 */ s32 colourref_size;
	/* 0x64 */ struct nucolourref_s *focolourref;
	/* 0x68 */ s32 focolourref_size;
};

struct nufgobj_s { // 0x5c
	/* 0x00 */ struct nugobj_s *sysnext;
	/* 0x04 */ struct nugobj_s *syslast;
	/* 0x08 */ enum gobjtype_s type;
	/* 0x0c */ int geom;
	/* 0x10 */ int faceon_geom;
	/* 0x14 */ float r;
	/* 0x18 */ float r2;
	/* 0x1c */ struct nuvec_s min;
	/* 0x28 */ struct nuvec_s max;
	/* 0x34 */ struct nuvec_s cntr;
	/* 0x40 */ float cntr_r;
	/* 0x44 */ float cntr_r2;
	/* 0x48 */ struct NUGOBJFLAGS_s flags;
	/* 0x4c */ int next_gobj;
	/* 0x50 */ union NUGOBJEX_s exdata;
};

struct NuGeom
{
    struct NuGeom* next;
    struct numtl_s* mtl;
	/* 0x08 */ void *dmastream;
	/* 0x0c */ void *skindma;
	/* 0x10 */ struct nutristream_s *tristream;
    s32 mtl_id;
    enum nuvtxtype_e vtxtype;
	/* 0x1c */ s32 vtxflags;
    s32 vtxcnt;
    s32 vtxmax;
	/* 0x28 */ struct NUVTX_TC1 *vtxptr;
    struct NuPrim* prims;
    struct NuSkin* skins;
    struct NUVTXSKININFO_s* vtxskininfo;
	/* 0x38 */ struct nuvec_s *cntrl_pts;
	/* 0x3c */ s32 ncntrl_pts;
	/* 0x40 */ s32 dma_len;
	/* 0x44 */ struct skinv_s *skinv;
	/* 0x48 */ struct NUBLENDGEOM *blendgeom;
	/* 0x4c */ s32 id;
}; // 0x50

struct NuPrim
{
    struct NuPrim* next;
    enum nuprimtype_e type;
    unsigned short cnt;
    unsigned short max;
    unsigned short* vid;
    struct nuplane_s* pln;
    s32 idxbuff;
    s32 cached;
    short skinmtxlookup[16];
}; // 0x3c

struct nufaceongeom_s
{
    struct nufaceongeom_s* next;
    struct numtl_s* mtl;
    s32 mtl_id;
    s32 faceon_type;
    struct nufaceon_s* faceons;
    s32 nfaceons;
    f32 faceon_radius;
    //void *dmastream;
}; // 0x30

// Size: 0x18
 struct nufaceon_s
{
    struct nuvec_s point;
    f32 width;
    f32 height;
    s32 colour;
};

 struct NUBLENDGEOM {
    s32 nblends;
    struct nuvec_s** blend_offsets;
    s32* ix;
    struct nuvec_s* offsets;
    //struct nuvec_s* ooffsets;
    //s32 hVB; //VertexBuffer, GS_Buffer * ?
    //s32 blendindex[10];
};

// Size: 0x10
struct NUVTXSKININFO_s
{
    f32 wts[3];
    unsigned char joint_ixs[3];
    unsigned char pad;
};

struct NuSkin
{
	struct NuSkin* next;
	s32 vtxoffset;
    s32 vtxcnt;
    s32 mtxcnt;
    s32* mtxid;
    f32* weights;
};


struct nugeomps2_s { // 0x14
	/* 0x00 */ struct NuGeom *next;
	/* 0x04 */ struct numtl_s *mtl;
	/* 0x08 */ void *dmastream;
	/* 0x0c */ void *skindma;
	/* 0x10 */ struct nutristream_s *tristream;
};

extern struct nusystex_s * tinfo;
extern s32 tpid;

typedef u32 uintptr_t;
#define READ_AT(type, x, pos) ( *(type*)( ((uintptr_t)x) + pos) )

/*
int NuTexCreateNative( void *data) {
	 int id;
	VARIPTR ptr;
	 NUTEX *tex;
	 PS2TEX *ptex;
	 int n;
	 int id;
}
*/

static inline int getPow2(int v) {
    int i;
    for (i = 0; 1 < v; i++) 
    {
        v >>= 1;
    }
    return i;
}

static inline int check_alloc() {
    int id;
    int iVar6;
    id = tpid;
    while (tinfo[tpid].used) {
        tpid++;
        if (id == tpid) {
            return -1;
        }
        if (tex_allocmax <= tpid) {
            tpid = 0;
        }
    }
    nutex_alloc_cnt++;
    return tpid;
}


int NuTexCreateNative(void *data)
{
    int *piVar4;
    int *piVar5;
    int iVar6;
    int *piVar7;
    struct nusystex_s *tex;
    struct ps2tex_s *ptex;
    int n;
    int id;
    struct nuparamtest_s *param_1;
    char pad[8]; // stack padding, remove if stack pointer differs 
    int var_a2;
    int var_t0;
    s32 tids;
    s32 i;

    // var_a2 = tpid;

    param_1 = data; 
    id = check_alloc();
    
    if (id >= 0)
    {
        if (param_1->unk2 == 0) {
            piVar7 = &param_1->unk10;
            tex = &tinfo[id];
            // pnVar8 = (int *)(tinfo + id);
            tex->used = 1;
            tex->xdef = 1;
            ptex = &tex->ps2tex;
            // tex->ref = id;
           // tex->tex = (struct ps2tex_s*)param_1->unkc;
            tex->tex.type = param_1->unkc;
            tex->tex.width = *(s32*)param_1;
            tex->tex.height = ((s32*)param_1)[1];
            tex->tex.mmcnt = param_1->unke - 1;
            tex->tex.bits = 0;
            tex->tex.pal = 0;
            memset(ptex, 0, sizeof(struct ps2tex_s));
            
            ptex->nummm = param_1->unke;
            ptex->psm = param_1->unkd;
            ptex->bltpsm = param_1->unkd;
            ptex->tcc = param_1->unkf;
            ptex->req = param_1->unk8;

            if (
                (tex->tex.type == NUTEX_PAL4) 
                || (tex->tex.type == NUTEX_PAL8)
                || (tex->tex.type == NUTEX_PAL4_S)
                || (tex->tex.type == NUTEX_PAL8_S)
            ) {
                ptex->clut_load = &param_1->unk20;
                ptex->clut_offset = READ_AT(u16, piVar7, 4);
                ptex->clut_width = READ_AT(u16, piVar7, 8);
                ptex->clut_psm = READ_AT(u16, piVar7, 12);
                ptex->clut_loadsize = READ_AT(u16, param_1, 0x10) - 0x10;
                piVar7 = (int)piVar7 + param_1->unk10;
            }

            for (i = 0; i < param_1->unke; i++) {
                tex->ps2tex.dt_load[i] = (uintptr_t)piVar7 + 0x10 + READ_AT(s32, piVar7, 0xC);
                tex->ps2tex.offset[i] = READ_AT(s32, piVar7, 0x4);
            
                tex->ps2tex.loadwidth[i] = READ_AT(u16, piVar7, 8);
                tex->ps2tex.bltwidth[i] = READ_AT(u16, piVar7, 8);
            
                tex->ps2tex.loadsize[i] = READ_AT(s32, piVar7, 0) - 0x10;
                piVar7 = (int *)((int)piVar7 + (READ_AT(s32, piVar7, 0) + READ_AT(s32, piVar7, 0xC)));
            }
            
            ptex->p2w = getPow2(tex->tex.width);
            ptex->p2h = getPow2(tex->tex.height);
        }
        else if (param_1->unk2 == 1) {
            tex = &tinfo[id];
            piVar7 = &param_1->unk10;
            tex->used = 1;
            tex->xdef = 1;
            ptex = &tex->ps2tex;
            
            tex->tex.type = param_1->unkc;
            tex->tex.width = READ_AT(u16, param_1, 0);
            tex->tex.height = READ_AT(u16, param_1, 4);
            tex->tex.mmcnt = (param_1->unkf & 0x7F) - 1;
            tex->tex.bits = 0;
            tex->tex.pal = 0;
            memset(ptex, 0, sizeof(struct ps2tex_s));
            
            ptex->nummm = (param_1->unkf & 0x7F);
            ptex->psm = param_1->unkd;
            ptex->bltpsm = param_1->unke;
            ptex->tcc = ((u32*)param_1)[3] >> 0x1f;
            ptex->req = param_1->unk8;

            if (
                (tex->tex.type == NUTEX_PAL4) 
                || (tex->tex.type == NUTEX_PAL8)
                || (tex->tex.type == NUTEX_PAL4_S)
                || (tex->tex.type == NUTEX_PAL8_S)
            ) {
                ptex->clut_load = &param_1->unk20;
                ptex->clut_offset = READ_AT(u16, piVar7, 4);
                ptex->clut_width = READ_AT(u16, piVar7, 8);
                ptex->clut_psm = READ_AT(u16, piVar7, 12);
                ptex->clut_loadsize = READ_AT(u16, param_1, 0x10) - 0x10;
                piVar7 = (int)piVar7 + param_1->unk10;
            }
            
            for (i = 0; i < (param_1->unkf & 0x7F); i++) 
            {
                tex->ps2tex.dt_load[i] = (uintptr_t)piVar7 + 0x14 + READ_AT(s32, piVar7, 0x10);
                tex->ps2tex.offset[i] = READ_AT(s32, piVar7, 0x4);
            
                tex->ps2tex.loadwidth[i] = READ_AT(u16, piVar7, 8);
                tex->ps2tex.bltwidth[i] = READ_AT(u16, piVar7, 0xC);
            
                tex->ps2tex.loadsize[i] = READ_AT(s32, piVar7, 0) - 0x14;
                piVar7 = (int *)((uintptr_t)piVar7 + (READ_AT(s32, piVar7, 0) + READ_AT(s32, piVar7, 0x10)));
            }
            
            ptex->p2w = getPow2(tex->tex.width);
            ptex->p2h = getPow2(tex->tex.height);
        } else {
            return 0;
        }
        
        return id + 1;
    }
    
    return 0;
}

//95.25%

s32 NuPs2CreateRenderTarget(struct nutex_s * tex, struct ps2tex_s * ptex);
s32 GenPaletteLoad(struct nutex_s * tex, struct ps2tex_s * ptex);
s32 GenTextureLoad(struct nutex_s * tex, struct ps2tex_s * ptex);
void QuantizeTexture(struct nutex_s *tex);          /* extern */
extern s32 numtl_force_mipmap;
extern s32 nutex_force_quantisation;
extern s32 palcnt;
s32 palette[256];
extern void* txbuff;

/*
	// struct nutex_s *ttex;
	// s32 n;
*/

static inline int NuMiscNextPow2Exp(int v) {
    s32 rv;
    s32 t;
    
    t = v;
    for (rv = 0; v >= 2; v >>= 1) {
        rv++;
    }
    
    if (t & ((1 << rv) - 1)) {
        rv++;
    }
    return rv;
}

s32 NuPs2TxCreate(struct nutex_s *tex, struct ps2tex_s *ptex) 
{
    s32 n;
    
    struct nutex_s ttex;
    
    switch(tex->type) {
        case NUTEX_RGB16:
        case NUTEX_RGBA16:
        case NUTEX_RGB24:
        case NUTEX_RGBA32:
        case NUTEX_PAL4:
        case NUTEX_PAL8:
        case NUTEX_PAL4_S:
        case NUTEX_PAL8_S:
        break;
        
        case NUTEX_RT8:
        case NUTEX_RTT8:
        case NUTEX_RT8H:
        case NUTEX_RT32:
        case NUTEX_RT24:
        case NUTEX_RT16:
        case NUTEX_RTT32:
        case NUTEX_RTT24:
        case NUTEX_RTT16:
        case NUTEX_RZT32:
        case NUTEX_RZT24:
        case NUTEX_RZT16:
        //case NUTEX_RTT8H:
        //case NUTEX_RTT16S:
            return NuPs2CreateRenderTarget(tex, ptex);
        default:
            NuErrorProlog("..\\nu2.ps2\\nups2\\ps2txtr.c", 0x63d)("unsupported texture format");
            return 0;
    }
    
    memset(ptex, 0, sizeof(struct ps2tex_s));
    
    palcnt = 0;
    if (nutex_force_quantisation != 0) {
        QuantizeTexture(tex);
    }
    
    if (palcnt != 0) {
        tex->type = NUTEX_PAL8;
        ttex = *(struct nutex_s *)tex;
        ttex.type = NUTEX_PAL8;
        ttex.bits = txbuff;
        ttex.pal = &palette;
        tex = &ttex;
        NuDebugMsgProlog("..\\nu2.ps2\\nups2\\ps2txtr.c", 0x650)("Quantized - %d colours", palcnt);
    }

    ptex->p2w = NuMiscNextPow2Exp(tex->width);
    ptex->p2h = NuMiscNextPow2Exp(tex->height);

    
    if ((tex->width != 0) && (1 << ((u16)ptex->p2w ) != tex->width)) {
        NuDebugMsgProlog("..\\nu2.ps2\\nups2\\ps2txtr.c", 0x659)
            ("\r\n*********************************************\r\nTexture width MUST be a power  of two, not %d\r\n*********************************************", tex->width);
    }
    
    if ((tex->height != 0) && (1 << ((u16)ptex->p2h ) != tex->height)) {
        NuDebugMsgProlog("..\\nu2.ps2\\nups2\\ps2txtr.c", 0x65c)
            ("\r\n*********************************************\r\nTexture height MUST be a power of two, not %d\r\n*********************************************", tex->height);
    }
    
    ptex->req = 0;
    if (tex->bits != NULL) {
        GenTextureLoad(tex, ptex);
        if (tex->mmcnt != 0) {
            for(n = 1; n < tex->mmcnt; n++) {
                GenTextureLoad(tex, ptex);
            }
        }
        else if(numtl_force_mipmap != 0) {
            while (GenTextureLoad(tex, ptex)) {
                // empty
            } 
        }
    }
    
    GenPaletteLoad(tex, ptex);
    switch (tex->type) {
        case NUTEX_PAL4_S:
            tex->width <<= 1;
            tex->height <<= 2;
        break;
        case NUTEX_PAL8_S:
            tex->width <<= 1;
            tex->height <<= 1;
        break;
    }

    while ((ptex->p2w > 0x200) || (ptex->p2h > 0x200)) {
        ptex->p2w = (ptex->p2w >> 1);
        ptex->p2h = ptex->p2h >> 1;
    }
    
    return 1;
}

int Conv4to32 (int width, int height, unsigned char *p_input, unsigned char *p_output);
int Conv8to32(int width, int height, unsigned char *p_input, unsigned char *p_output);
void *NuMemAllocFn (int size, char * file, int line);
void NuMemFreeFn( void *addr, char *file, int line);

//98%
void NuTexSwizzelBits(struct nutex_s *tex) {
  unsigned char *bits;
  unsigned char *ptr;
  int size;
  int i;
  int j;
  int w;
  int h;
  int uVar6;
  int mmcnt;
  
  mmcnt = tex->mmcnt;
  if (mmcnt < 2) {
    if (mmcnt != 0) {
      uVar6 = mmcnt - 1;
    } else {
      uVar6 = 0;
    }
    switch(tex->type) {
        case NUTEX_PAL4:
          if (tex->width >> uVar6 > 0x7f) {
              bits = (unsigned char *)tex->bits;
              for(i = 0; i <= uVar6; i++) {
                w = tex->width >> (i);
                h = tex->height >> (i);
                size = w * h >> 1;
                for(j = 0; j < size; j++) {
                    bits[j] = bits[j] >> 4 | bits[j] << 4;
                }
                ptr = NuMemAllocFn(size,"..\\nu2.ps2\\nu3d\\bitconv.c",0x2dd);
                Conv4to32(w,h,bits,ptr);
                memcpy(bits,ptr,size);
                NuMemFreeFn(ptr,"..\\nu2.ps2\\nu3d\\bitconv.c",0x2e1);
                bits += size;
              }
            
            size = (tex->height >= 0) ? tex->height : tex->height + 3;
            tex->height = size >> 2;
            tex->type = NUTEX_PAL4_S;
            tex->width = tex->width / 2;
          }
        break;
        case NUTEX_PAL8:
            if(tex->width >> uVar6 > 0x7f) {
                bits = (unsigned char *)tex->bits;
                for(i = 0; i <= uVar6; i++) {
                  w = tex->width >> (i);
                  h = tex->height >> (i);
                  size = w * h;
                  ptr = (unsigned char *)NuMemAllocFn(size,"..\\nu2.ps2\\nu3d\\bitconv.c",0x2f0);
                  Conv8to32(w,h,bits,ptr);
                  memcpy(bits,ptr,size);
                  NuMemFreeFn(ptr,"..\\nu2.ps2\\nu3d\\bitconv.c",0x2f4);
                  bits = bits + size;
                }
              tex->type = NUTEX_PAL8_S;
              tex->width = tex->width / 2;
              tex->height = tex->height / 2;
            }
        break;
    }
  }
  return;
}