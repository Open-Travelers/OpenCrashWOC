union variptr_u buffer_start;
union variptr_u buffer_tmpstart;
union variptr_u *buffer_tmpend;
union variptr_u *buffer_tmpptr;
union variptr_u *buffer_endptr;
union variptr_u *buffer_freeptr;
struct nugscn_s *gscene;
s32 scene_version;
struct numemfile_s memfiles[20];
struct gsc_context_s gsc_load_context;
void* readfile_base;
extern s32 gscn_dbg;

extern s32 nutex_alloc_cnt;
extern s32 tex_allocmax;


#define ALIGN_ADDRESS(addr, al) (((s32)addr + (al-1)) & ~(al-1))
#define LOWERCASE(in) ((in >= 0x41 && in <= 0x5A) ? in + 0x20 : in)
#define SQUARE(in) ((in) * (in))
#define SQUARE_SUM(x, y, z) (SQUARE(x) + SQUARE(y) + SQUARE(z))
#define MAX(a, b) ((a < b) ? b : a)
// Square euclidean distance
#define DIST_FROM_POINT(a, b, c, p) ((SQUARE(a - p.x) + SQUARE(b - p.y) + SQUARE(c - p.z)))

void* NuMemFileAddr(int param_1)
{
  return memfiles[param_1 + -0x400].curr;
}

static inline void* NuGScnBufferAllocAligned(union variptr_u *ptr, s32 size, s32 alignment) {
    u32 mem;
    mem = ALIGN_ADDRESS(ptr->voidptr, alignment);
    
    if ((mem + size) < (s32)buffer_tmpptr) {
        ptr->u32 = mem + size;
        return mem;
    }
    else {
        NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0x181)("NuGScnBufferAllocAligned failed, scene ptr overrun. ");
        return 0;
    }
}

//98%
struct nugscn_s* NuGScnRead(union variptr_u *ptr, union variptr_u *buffend, char *filename)
{
    struct nugscn_s *gsc;
    void *mem;
    int sz;
    
    buffer_freeptr = ptr;
    buffer_start = *ptr;
    buffer_endptr = buffend;
    if (buffer_tmpstart.voidptr != 0) {
        buffer_tmpptr = buffer_tmpend;
    } else {
        buffer_tmpptr = buffend;
    }

    readfile_base = mem = NuGScnBufferAllocAligned(buffer_freeptr, 0, 0x80);
    sz = (s32)buffend - ptr->intaddr;
    gsc_load_context.size = NuFileLoadBuffer(filename, mem, sz);
    gsc_load_context.mem = mem;
    gsc_load_context.freeptr = ptr;
    gsc_load_context.endptr = buffend;
    gsc_load_context.file = filename;
    
    if (gsc_load_context.size == 0) {
        gsc = NULL;
    }
    else {
        gsc = NuGScnLoadFix();
    }
    return gsc;
}

//98%
void NuGScnUpdate(float param_1,struct nugscn_s *gsc)
{
    int iVar6;
    int ani_ix;
    struct nuinstance_s *inst_;
    int ninst;
    float unaff_f20;
    struct nuanimtime_s atime;
    struct numtx_s mtx;
    struct nuinstanim_s* anim;
    struct nuanimdata_s* instanim;

    ninst = gsc->numinstance;
    inst_ = &gsc->instances[ninst];
    while (ninst != 0)
    {
        inst_--;
        ninst--;
        if ((gscn_dbg != 0) && (gscn_dbg != ninst)) {
            continue;
        }
        
        anim = inst_->anim;
        iVar6 = inst_->flags.visitest;
        if (inst_->flags.visible == 0) {
            iVar6 = 0;
        }
        
        if (iVar6 == 0) {
            continue;
        }
        
        if (inst_->anim == NULL) {
            continue;
        }
        
        if (gsc->instanimdata == NULL) {
            continue;
        }
        
        if (gsc->instanimdata[inst_->anim->anim_ix] == NULL) {
            continue;
        }

        
        instanim = gsc->instanimdata[inst_->anim->anim_ix];
        if (anim->playing) {
            anim->ltime += param_1 * anim->tfactor;
            if ((anim->waiting) && (anim->tfirst <= anim->ltime)) {
                anim->waiting = 0; 
                anim->ltime -=  anim->tfactor - 1.0f;
            }
            
            if (!anim->waiting) {
                if ((instanim->time + anim->tinterval) <= anim->ltime) {
                    if (anim->repeating) {
                        while ((instanim->time + anim->tinterval) <= anim->ltime)
                        {
                            if (anim->oscillate) {
                                anim->backwards = !anim->backwards;
                            }
                            anim->ltime = (anim->ltime + 1.0f) - (instanim->time + anim->tinterval);
                        }
                        unaff_f20 = anim->ltime;
                    }
                    else {
                        anim->playing = 0;
                        unaff_f20 = anim->ltime = instanim->time;
                    }
                }
                else if (anim->ltime < unaff_f20) {
                    unaff_f20 = anim->ltime;
                }
                else {
                    unaff_f20 = instanim->time;
                }
                if (anim->backwards) {
                    unaff_f20 = (instanim->time + 1.0f) - unaff_f20;
                }
            }
        }
        else {
            unaff_f20 = anim->ltime;
        }
        
        NuAnimDataCalcTime(instanim, unaff_f20, &atime);
        NuAnimCurveSetApplyToMatrix(*instanim->chunks[atime.chunk]->animcurvesets, &atime, &mtx);
        memcpy(&anim->mtx, &mtx, sizeof(struct numtx_s));
        NuMtxTranslate(&anim->mtx, (struct NuVec *)&inst_->mtx._30);
    }
    return;
}

void NuCvtGeoFixup(struct nucolourref_s* arg0, void* arg1) {
        while(arg0->count != 0)
        {
            arg0->addr = (s32) ((char*)arg1 + (s32)arg0->addr);
            arg0 = (char*)arg0 + ((arg0->count * 8) + 8);
        }
}

//98%
void ReadObjSet(s32 fh) {
    s32 sp14;
    s32 sp18;
    s32 sp1C;
    s32 temp_s0_2;
    s32 temp_s5;
    s32 temp_s6;
    s32 temp_s6_2;
    s32 temp_v0_5;
    s32 var_a0;
    struct nufaceongeom_s *var_s0_3; //nufaceongeom_s
    struct nugobj_s* var_s1;
    int i;
    int j;
    int k;
    int l;
    struct nugeom_s *geo;
    struct nufaceongeom_s *fgeo;
    int numgobj;
    struct NuVec uStack_f0;
    struct _sceDmaTag *dmastr;

    memset(&uStack_f0, 0, sizeof(struct NuVec));
    NuDebugMsgProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xb59)("Reading Objset set...");
    numgobj = NuFileReadInt(fh);
    sp18 = NuFileReadInt(fh);
    gscene->gobjs = NuGScnBufferAllocAligned(buffer_freeptr, numgobj * sizeof(struct nugobj_s*), 0x4);
    memset(gscene->gobjs, 0, numgobj * 4);
    gscene->numgobj = numgobj;
    
    for (i = 0; i < numgobj; i++) {
        sp14 = NuFileReadInt(fh);
        NuFileReadInt(fh);
        NuFileReadInt(fh);
        NuFileReadInt(fh);
        
        gscene->gobjs[i] = var_s1 = NuGScnBufferAllocAligned(buffer_freeptr, sp14 * sizeof(struct nugobj_s), 0x4);
        
        memset(var_s1, 0, sp14 * sizeof(struct nugobj_s));
        var_s1->flags = sp14;
        for (j = 0; j < sp14; j++){
            var_s1->type = NuFileReadInt(fh);
            switch (var_s1->type) {
                case 0:
                    temp_s6 = NuFileReadInt(fh);
                    NuFileRead(fh, &var_s1->origin, sizeof(struct NuVec));
                    geo = var_a0 = NuGScnBufferAllocAligned(buffer_freeptr, temp_s6 * sizeof(struct nugeom_s), 0x4);
                    
                    memset(var_a0, 0, temp_s6 * sizeof(struct nugeom_s));
                    
                    sp1C = NuFileReadInt(fh);
                    NuFileReadInt(fh);
                    NuFileReadInt(fh);
                    var_s1->geom = geo;
                    memset(geo, 0, temp_s6 * sizeof(struct nugeom_s));
                    
                    for (k = 0; k < temp_s6; k++) {
                        
                        if (k != (temp_s6 - 1)) {
                            geo->next = geo + 1;
                        }
                        
                        NuFileReadInt(fh);
                        temp_s0_2 = NuFileReadInt(fh);
                        geo->mtl = (struct numtl_WoC* )gscene->mtls[NuFileReadInt(fh)];
                        NuMemFileSeek(fh, temp_s0_2, 1);
                        temp_v0_5 = NuFileReadInt(fh);
                        if (temp_v0_5 & 0xF) {
                            NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xb92)("invalid qwc");
                        }

                        // bitfields man
                        if ((geo->mtl->attrib.ot) == 1) {
                            geo->tristream = NuMemFileAddr(fh);
                            // ?????
                            for (l = 0; l < geo->tristream->count; l++) {
                                s32 t = (s32)(&((struct nuvutri_s*)geo->tristream)[l]);
                                s32 t1 = (s32)(&((struct nuvutri_s*)geo->tristream)[l+1]);
                                *(s32*)(t + 0x14) = (s32)(t1 + 0x10);
                            }
                        } else {
                            struct _sceDmaTag *tag;
                            s32 temp;
                            
                            dmastr = NuMemFileAddr(fh);
                            geo->dmastream = dmastr;
                            if ((s32)dmastr & 0x7F) {
                                NuDebugMsgProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xb9d)("Geom DMASTREAM not 128 byte aligned");  
                            }

                            tag = geo->dmastream; 
                            while (tag->id == 0x20) {
                                tag = tag->next = (s32)tag->next + (s32)tag;
                            }
                        }
                        NuMemFileSeek(fh, temp_v0_5, 1);
                        geo++;
                    }
                    var_s1->colourref_size = sp1C;
                    break;
                case 1:
                    temp_s6_2 = NuFileReadInt(fh);
                    NuFileReadInt(fh);
                    NuFileReadInt(fh);
                    var_s1->origin = uStack_f0;
                    fgeo = var_s0_3 = NuGScnBufferAllocAligned(buffer_freeptr, temp_s6_2 * sizeof(struct nufaceongeom_s), 0x4);
                    memset(var_s0_3, 0, temp_s6_2 * sizeof(struct nufaceongeom_s));
                    var_s1->faceon_geom = fgeo;
                    
                    for (k = 0; k < temp_s6_2; k++) {
                        
                        if (k != (temp_s6_2 - 1)) {
                            fgeo->next = fgeo + 1;
                        }
                        
                        fgeo->mtl = gscene->mtls[NuFileReadInt(fh)];
                        fgeo->faceon_type = NuFileReadInt(fh);
                        fgeo->faceon_radius = NuFileReadFloat(fh);
                        temp_s5 = NuFileReadInt(fh);
                        fgeo->dmastream = NuMemFileAddr(fh);
                        NuMemFileSeek(fh, temp_s5, 1);
                        fgeo++;
                    }
                    break;
                default:
                    NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xbcf)("Unknown geom type");
                    break;
            }
            NuFileRead(fh, &var_s1->min, 0xC);
            NuFileRead(fh, &var_s1->max, 0xC);
            NuFileReadInt(fh);
            NuFileReadInt(fh);
            
            var_s1->cntr.x = (var_s1->min.x + var_s1->max.x) * 0.5f;
            var_s1->cntr.y = (var_s1->min.y + var_s1->max.y) * 0.5f;
            var_s1->cntr.z = (var_s1->min.z + var_s1->max.z) * 0.5f;


            var_s1->r2 =     SQUARE_SUM(var_s1->min.x, var_s1->min.y, var_s1->min.z);
            var_s1->r2 = MAX(SQUARE_SUM(var_s1->max.x, var_s1->min.y, var_s1->min.z), var_s1->r2);
            var_s1->r2 = MAX(SQUARE_SUM(var_s1->min.x, var_s1->max.y, var_s1->min.z), var_s1->r2);
            var_s1->r2 = MAX(SQUARE_SUM(var_s1->max.x, var_s1->max.y, var_s1->min.z), var_s1->r2);
            var_s1->r2 = MAX(SQUARE_SUM(var_s1->min.x, var_s1->min.y, var_s1->max.z), var_s1->r2);
            var_s1->r2 = MAX(SQUARE_SUM(var_s1->max.x, var_s1->min.y, var_s1->max.z), var_s1->r2);
            var_s1->r2 = MAX(SQUARE_SUM(var_s1->min.x, var_s1->max.y, var_s1->max.z), var_s1->r2);
            var_s1->r2 = MAX(SQUARE_SUM(var_s1->max.x, var_s1->max.y, var_s1->max.z), var_s1->r2);
            
            var_s1->r = sqrt(var_s1->r);
            
            var_s1->cntr_r2 =     DIST_FROM_POINT(var_s1->min.x, var_s1->min.y, var_s1->min.z, var_s1->cntr);
            var_s1->cntr_r2 = MAX(DIST_FROM_POINT(var_s1->max.x, var_s1->min.y, var_s1->min.z, var_s1->cntr), var_s1->cntr_r2);
            var_s1->cntr_r2 = MAX(DIST_FROM_POINT(var_s1->min.x, var_s1->max.y, var_s1->min.z, var_s1->cntr), var_s1->cntr_r2);
            var_s1->cntr_r2 = MAX(DIST_FROM_POINT(var_s1->max.x, var_s1->max.y, var_s1->min.z, var_s1->cntr), var_s1->cntr_r2);
            var_s1->cntr_r2 = MAX(DIST_FROM_POINT(var_s1->min.x, var_s1->min.y, var_s1->max.z, var_s1->cntr), var_s1->cntr_r2);
            var_s1->cntr_r2 = MAX(DIST_FROM_POINT(var_s1->max.x, var_s1->min.y, var_s1->max.z, var_s1->cntr), var_s1->cntr_r2);
            var_s1->cntr_r2 = MAX(DIST_FROM_POINT(var_s1->min.x, var_s1->max.y, var_s1->max.z, var_s1->cntr), var_s1->cntr_r2);
            var_s1->cntr_r2 = MAX(DIST_FROM_POINT(var_s1->max.x, var_s1->max.y, var_s1->max.z, var_s1->cntr), var_s1->cntr_r2);
            
            var_s1->cntr_r = sqrt(var_s1->cntr_r2);
            
            var_s1++;
        }
        
        gscene->gobjs[i]->colourref = 0;
        gscene->gobjs[i]->focolourref = 0;
        if (sp18 == 1) {
            gscene->gobjs[i]->colourref_size = NuFileReadInt(fh);
            NuFileReadInt(fh);
            NuFileReadInt(fh);
            NuFileReadInt(fh);
            if (gscene->gobjs[i]->colourref_size != 0) {
                gscene->gobjs[i]->colourref = NuMemFileAddr(fh);
                NuMemFileSeek(fh, gscene->gobjs[i]->colourref_size, 1);
                NuCvtGeoFixup(gscene->gobjs[i]->colourref, readfile_base);
            }
        }
    }
}

static inline void ReadInstSet(s32 fh) {
    int i;
    
    gscene->numinstance = NuFileReadInt(fh);
    NuFileReadInt(fh);
    gscene->instances = NuMemFileAddr(fh);
    NuMemFileSeek(fh, gscene->numinstance * sizeof(struct nuinstance_s), 1);
    
    for (i = 0; i < gscene->numinstance; i++) {
        gscene->instances[i].flags.visitest = 1;
    }
}

static inline void ReadNameTable(s32 fh) {
    int i;
    int size;
    
    size = NuFileReadInt(fh);
    gscene->nametable = NuMemFileAddr(fh);
    NuMemFileSeek(fh, size, 1);
    
    for (i = 0; i < size; i++){
        gscene->nametable[i] = LOWERCASE(gscene->nametable[i]);
    }
}

static inline void ReadSpecialSet(s32 fh) {
    int i;
    struct nuspecial_s *sp;
    struct nuinstance_s *ins;
    
    gscene->numspecial = NuFileReadInt(fh);
    NuFileReadInt(fh);
    gscene->specials = NuMemFileAddr(fh);
    ins = NuMemFileAddr(fh); // check this
    NuMemFileSeek(fh, gscene->numspecial * sizeof(struct nuspecial_s), 1);
    
    sp = gscene->specials;
    for (i = 0; i < gscene->numspecial; i++) {
        sp->mtx = gscene->instances[ins->objid].mtx;
        sp->instance = &gscene->instances[ins->objid];
        sp->name =  (s32)gscene->nametable + *(s32*)&ins->flags; // check this?
        sp->flags.ext = 0;
        sp++;
        ins++;
    }
}

// Dunno about the name, it was commented as INSTANIMBLOCK
static inline void ReadInstAnim(s32 fh) {
    int i;
    struct nuinstanim_s* anim;
    struct nuinstanim_s* p_anim;
    
    NuFileReadInt(fh);
    NuFileReadInt(fh);
    gscene->instanimblock = NuMemFileAddr(fh);
    
    anim = gscene->instanimblock;
    if (gscene->instanimblock != NULL) {
        for (i = 0; i < gscene->numinstance; i++)  {
            if (gscene->instances[i].anim != NULL){
                gscene->instances[i].anim = anim++;
                // gscene->instances[i].anim->mtx = anim->mtx;
                // needs to be explicit? Probably inline memes
                memcpy(gscene->instances[i].anim, &gscene->instances[i], 0x40);
            }
        }
    }
}

static inline void ReadInstId(s32 fh) {
        gscene->numinstanceixs = NuFileReadInt(fh);
         NuFileReadInt(fh);
         gscene->instanceixs = NuMemFileAddr(fh);
}

void ReadTextureSet(s32 fh) {
    s32* faddr;
    s32 temp_s3;
    s32 temp_s4;
    s32 off1;
    s32 i;

    NuDebugMsgProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xa8d)("Reading type 2 texture set header...");
    temp_s4 = NuFileReadInt(fh);
    NuFileReadInt(fh);
    gscene->tids = NuGScnBufferAllocAligned(buffer_freeptr, temp_s4 * 4, 4);
    memset(gscene->tids, 0, temp_s4 * 4);
    gscene->numtid = temp_s4;
    for(i = 0; i < temp_s4; i++) {
        temp_s3 = NuFileReadInt(fh);
        off1 = NuFileReadInt(fh);
        if (off1 == 0) {
            NuFileReadInt(fh);
            NuFileReadInt(fh);
        } else {
            NuFileSeek(fh, off1, 1);
        }
        faddr = NuMemFileAddr(fh);
        NuMemFileSeek(fh, temp_s3, 1);
        gscene->tids[i] = NuTexCreateNative(faddr); //faddr --> struct?
    }
}


//98%
void ReadAnimationLibrary(s32 fh) {
    struct nuanimcurve_s *pNVar1;
    struct nugscn_s *pnVar2;
    s32 numanim;
    struct nuanimdata_s **ppnVar4;
    struct nuanimdata_s **t;
    struct nuanimdata_s *pnVar5;
    struct nuanimdatachunk_s *pnVar6;
    struct nuanimcurveset_s *pNVar7;
    struct nuanimkey_s *pNVar8;
    struct nuanimdatachunk_s **ppnVar9;
    struct nuanimcurveset_s **ppNVar10;
    float *pfVar11;
    struct nuanimcurve_s **ppNVar12;
    s32 i;
    s32 ncurves;
    s32 nKeys;
    s32 nChunks;
    
    numanim = NuFileReadInt(fh);
    NuFileReadInt(fh);
    gscene->instanimdata = NuMemFileAddr(fh);
    pnVar2 = gscene;
    
    for (i = 0; i < numanim; i++)
    {
        ASSIGN_IF_SET(pnVar2->instanimdata[i], ((s32)&pnVar2->instanimdata[i] + (s32)pnVar2->instanimdata[i]));
        pnVar5 = pnVar2->instanimdata[i];
        if (pnVar5 != NULL) {
            ASSIGN_IF_SET(pnVar5->chunks, ((s32)&pnVar5->chunks + (s32)pnVar5->chunks));
            
            for(nChunks = 0; nChunks < pnVar5->nchunks; nChunks++)
            {
                ASSIGN_IF_SET(pnVar5->chunks[nChunks], ((s32)&pnVar5->chunks[nChunks] + (s32)pnVar5->chunks[nChunks]));
                pnVar6 = pnVar5->chunks[nChunks];
                ASSIGN_IF_SET(pnVar6->animcurvesets, ((s32)&pnVar6->animcurvesets + (s32)(pnVar6->animcurvesets)));
                
                for (nKeys = 0; nKeys < pnVar6->numnodes; nKeys++)
                {
                    ASSIGN_IF_SET(pnVar6->animcurvesets[nKeys], ((s32)&pnVar6->animcurvesets[nKeys] + (s32)pnVar6->animcurvesets[nKeys]));
                    pNVar7 = pnVar6->animcurvesets[nKeys];
                    ASSIGN_IF_SET(pNVar7->constants, ((s32)(&pNVar7->constants) + (s32)pNVar7->constants));
                    ASSIGN_IF_SET(pNVar7->set, ((s32)(&pNVar7->set) + (s32)pNVar7->set));
                    
                    for (ncurves = 0; ncurves < pNVar7->ncurves; ncurves++)
                    {
                        ppNVar12 = &pNVar7->set[ncurves];
                        if (pNVar7->set[ncurves] == NULL) {
                            continue;
                        }
                        pNVar7->set[ncurves] = (struct nuanimcurve_s *)((s32)&pNVar7->set[ncurves] + (s32)pNVar7->set[ncurves]);
                        pNVar1 = pNVar7->set[ncurves];
                        ASSIGN_IF_SET(pNVar1->animkeys, ((s32)(&pNVar1->animkeys) + (s32)pNVar1->animkeys));
                    }
                }
            }
        }
    }
    return;
}

struct nugscn_s * NuGScnLoadFix(void)
{
    void *start;
    char* filename;
    int filesize;
    int fh;
    int fileversion;
    int filemagic;
    union variptr_u *freeptr;
    struct nugscn_s *scene;
    
    gscene = NULL;
    timeUserReset();
    freeptr = gsc_load_context.freeptr;
    filename = gsc_load_context.file;
    filesize = gsc_load_context.size;
    
    if (filesize <= 0) {
        return gscene;
    }

    start = NuGScnBufferAllocAligned(buffer_freeptr, filesize, 0x10);
    
    if (start == NULL) {
        NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xefd)("GSC File too large, \"%s\" ", filename);
    }

    gscene = NuGScnBufferAllocAligned(buffer_freeptr, sizeof(struct nugscn_s), 0x04);
    if (gscene != NULL) {
        memset(gscene, 0, sizeof(struct nugscn_s));
        fh = NuMemFileOpen(start, filesize, NUFILE_READ);
        if (fh != 0) {
            NuFileBeginBlkRead(fh, 0x3032554e); // NU20
            fileversion = NuFileReadInt(fh);
            NuFileReadInt(fh);
            if (fileversion < scene_version) {
                NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xf09)("GSC File out of date - need newer \"%s\" file", filename);
            }
            if (scene_version < fileversion) {
                NuErrorProlog("..\\nu2.ps2\\nu3d\\nugscn.c", 0xf0c)("Loader out of date - need newer 3D");
            }
            
            while (filemagic = NuFileBeginBlkRead(fh, 0)) {
                DbgBlkType(filemagic);
                switch (filemagic) {
                    // TST0
                    // TST2
                    case 0x30545354:
                    case 0x32545354:
                        ReadTextureSet(fh);
                        break;
                    // MS00
                    // MS02
                    case 0x3030534d:
                    case 0x3230534d:
                        ReadMaterialSet(fh);
                        break;
                    // OBJ0
                    case 0x304a424f:
                        ReadObjSet(fh);
                        break;
                    // INST
                    case 0x54534e49:
                        ReadInstSet(fh);
                        break;
                    // NTBL
                    case 0x4c42544e:
                        ReadNameTable(fh);
                        break;
                    // SPEC
                    case 0x43455053:
                        ReadSpecialSet(fh);
                        break;
                    // SST0
                    case 0x30545353:
                        ReadSplineSet(fh);
                        break;
                    // IABL
                    case 0x4c424149:
                        ReadInstAnim(fh);
                        break;
                    // ALIB
                    case 0x42494c41:
                        ReadAnimationLibrary(fh);
                        break;
                    // INID
                    case 0x44494e49:
                        ReadInstId(fh);
                        break;
                    // MS00
                    case 0x30534154:
                        ReadTexAnimSet(fh);
                        break;                        
                }
                NuFileEndBlkRead(fh);
            }
            NuFileEndBlkRead(fh);
            NuMemFileClose(fh);
        }
        
        (*freeptr).u32 = ALIGN_ADDRESS((*freeptr).u32, 0x10U);
        NuRndrSplineSearch(gscene);
    }
    return gscene;
}


//WIP
struct NUHGOBJFILE_s
{
    s32 field0_0x0;
    s32 version;
    s32 numtid;
    s32 field6_0xc;
    s32 nummtl;
    s32 field8_0x14;
    char num_joints;
    char field16_0x19;
    char field17_0x1a;
    char field18_0x1b;
    s32 field10_0x1c;
    s32 field11_0x20;
    s32 field15_0x24;
    char num_joint_ixs;
    char field16_0x29;
    char field17_0x2a;
    char field18_0x2b;
    s32 field23_0x2c;
    char* string_table;
    s32 string_table_size;
    s32 num_poi_ixs;
    s32 field39_0x3c;
    s32 num_points_of_interest;
    s32 field47_0x44;
    u8 num_layers;
    char field49_0x49;
    char field50_0x4a;
    char field51_0x4b;
    s32 field55_0x4c;
    s32 field59_0x50;
    float sphere_radius;
    float sphere_yoff;
    float field71_0x5c;
    float field75_0x60;
    float field79_0x64;
    float field83_0x68;
    float field87_0x6c;
    float field91_0x70;
    float cylinder_yoff;
    float cylinder_height;
    float cylinder_radius;
    s32 field107_0x80;
    float tbrdist;
    s32 numtexanims;
    s32 field119_0x8c;
};


//80% WIP
struct NUHGOBJ_s* NuGHGRead(union variptr_u *buff, char *name)
{
    //undefined *puVar1; //memcpy stuff
    //float *pfVar2;
    //u32 uVar4;
    u32 uVar5;
    //u32 *puVar6;
    union variptr_u mem;
    s32 iVar8;
    struct numtl_WoC **ppNVar11;
    s32 iVar12;     //struct?
    s32 **ppiVar13;
    s32 **ppiVar14;
    s32 iVar15;
    //struct NuGeom *pNVar16;
    struct numtl_WoC *pNVar17;
    void *pvVar18;
    struct NuGeom *pnVar19;
    struct NuGobj *pnVar20;
    //struct NuGobj *pNVar21;
    struct NUSHADOWDATA_s *pNVar22;
    s32 lVar23;
    u32 uVar24;
    s32 *piVar25;
    //struct NUCOLLISIONHDR_s *pNVar26;
    //struct nutexanim_s *pNVar27;
    short *psVar28;
    struct NUSHADOWMESH_s *pNVar29;
    u32 uVar30;
    struct NUCOLLISIONDATA_s *pNVar31;
    struct NuGeom *pnVar32;
    struct nutexanim_s *txanm;
    //undefined8 unaff_s0;
    s32 iVar33;    //struct?
    struct NuGobj *pnVar34;
    u32 uVar35; //cnt
    struct NUHGOBJ_s *__s;
    struct NULAYERDATA_s *pNVar36;
    struct NuGobj **ppNVar37;
    //float fVar38;
    union variptr_u *local_b0; //variptr_u
    //union variptr_u *local_ac;
    //char *local_a8;
    //struct NULAYERDATA_s *local_a4;
    //s32 local_a0 [5];
    struct NUHGOBJFILE_s *pvVar6;
    union variptr_u *sp0;
    struct NUJOINTDATA_s* joint;
    __s = NULL;
    //////
    //local_a0[0] = (s32)unaff_s0;
    //local_a0[1] = (s32)((u32)unaff_s0 >> 0x20);
    //////
    // mem.intaddr = ALIGN_ADDRESS(buff->voidptr, 0x10U);
    sp0 = ALIGN_ADDRESS(buff->voidptr, 0x10U);
    // local_b0 = (union variptr_u *)mem.intaddr;
    //local_ac = buff;
    //local_a8 = name;
    // pvVar6 = (struct NUHGOBJ_s *)local_b0;
    iVar8 = NuFileLoadBuffer(name, sp0, 0x7fffffff);
    pvVar6 = sp0->voidptr;
    if (iVar8 > 0) {
        if (ghg_version > pvVar6->version) 
            NuErrorProlog("..\\nu2.ps2\\nu3d\\nuhgobj.c", 0x61a)("GHG file is out of date - needs to be reconverted (FILE VER:%d SYS VER:%d)", pvVar6->numtid, ghg_version);
        if (pvVar6->version > ghg_version)
            NuErrorProlog("..\\nu2.ps2\\nu3d\\nuhgobj.c", 0x61c)("GHG loader is out of date - need newer 3d system (FILE VER:%d SYS VER:%d)", pvVar6->numtid, ghg_version);

    
        NuDebugMsgProlog("..\\nu2.ps2\\nu3d\\nuhgobj.c", 0x61f)("Reading %s", name);
        __s = (struct NUHGOBJ_s *)ALIGN_ADDRESS((*(s32*)buff + (s32)(buff)), 0x10U);
        buff = __s + 1;
        memset(__s, 0, 0x84);
        __s->loadtype = 1;
        if (pvVar6->field6_0xc != 0) {
            __s->tids = (s32)mem.s16 + pvVar6->field6_0xc;
            __s->numtid = pvVar6->numtid;
            piVar25 = (s32 *)((s32)mem.voidptr + pvVar6->field6_0xc);
            for ( iVar8 = 0; iVar8 < __s->numtid; iVar8++ ) {
                __s->tids[iVar8] = NuTexCreateNative((s32)mem.voidptr + piVar25[iVar8]);
            }
        }
        
        if (pvVar6->field8_0x14 != NULL) {
            __s->mtls = (struct numtl_WoC **)((s32)mem.voidptr + (s32)pvVar6->field8_0x14);
            __s->nummtl = pvVar6->nummtl;
            for ( iVar8 = 0; iVar8 < __s->nummtl; iVar8++ ) {
                __s->mtls[iVar8] = (struct numtl_WoC *)((s32)mem.voidptr + (s32)__s->mtls[iVar8]);
                uVar5 = __s->mtls[iVar8]->field373_0x1a4;
                if (uVar5 != 0) {
                    __s->mtls[iVar8]->field373_0x1a4 = (s32)__s->tids[uVar5 - 1];
                }
                NuDisableVBlank();
                NuMtlAdd(__s->mtls[iVar8]);
                if ((*NuMtlReadEvent)(__s->mtls[iVar8]) == 0) {
                    NuMtlUpdate(__s->mtls[iVar8]);
                }
                NuEnableVBlank();
            }
        }
        
        __s->tbrdist = pvVar6->tbrdist;
        __s->string_table = mem.s8 + (s32)pvVar6->string_table;
        __s->string_table_size = pvVar6->string_table_size;
        __s->num_joints = (s32)pvVar6->num_joints & 0xFF; // check this field
        __s->joints = (struct NUJOINTDATA_s *)((s32)mem.voidptr + (s32)pvVar6->field10_0x1c);
        __s->T = (s32)mem.mtx44 + (s32)pvVar6->field11_0x20;
        __s->INV_WT = (s32)mem.mtx44 + (s32)pvVar6->field15_0x24;
        __s->num_joint_ixs = pvVar6->num_joint_ixs;
        __s->joint_ixs = mem.u8 + (s32)pvVar6->field23_0x2c;
        
        for (iVar8 = 0; iVar8 < __s->num_joints; iVar8++) { 
            if (__s->joints[iVar8].name != 0) {
                __s->joints[iVar8].name += (s32)mem.voidptr;
            }
        }

        // check this field
        if (pvVar6->num_poi_ixs != 0) {
            __s->num_poi_ixs = pvVar6->num_poi_ixs;
            __s->poi_ixs = mem.u8 + (s32)pvVar6->field39_0x3c;
        }

        // check this field
        if (pvVar6->num_points_of_interest != 0) {
            __s->num_points_of_interest = pvVar6->num_points_of_interest;
            // check this field
            __s->points_of_interest = (struct NUPOINTOFINTEREST_s *)((s32)mem.voidptr + *(s32*)&pvVar6->field47_0x44 );
            
            for (iVar8 = 0; iVar8 < __s->num_points_of_interest; iVar8++) {
                if (__s->points_of_interest[iVar8].name != 0) {
                    __s->points_of_interest[iVar8].name += (s32)mem.voidptr;
                }
            } 
        }
        
        // check this field
        pNVar36 = (struct NULAYERDATA_s *)((s32)mem.voidptr + *(s32*)&pvVar6->field55_0x4c);
        __s->layers = pNVar36;
        __s->num_layers = pvVar6->num_layers;
        for (iVar8 = 0; iVar8 < __s->num_layers; iVar8++) {
            if (pNVar36->name != NULL) {
                pNVar36->name = pNVar36->name + (s32)mem.s8;
            }
            //local_a4 = pNVar36 + 1;
            // iVar8 = iVar8 + 1;
            if (pNVar36->gobjs != NULL) {
                ppNVar37 = (struct NuGobj **)((s32)pNVar36->gobjs + (s32)mem.voidptr);
                pNVar36->gobjs = ppNVar37;
                for (iVar33 = 0; iVar33 < __s->num_joints; iVar33++) {
                    piVar25 = (s32 *)(ppNVar37[iVar33]);
                    iVar12 = *piVar25;
                    if (iVar12 != 0) {
                        iVar12 = iVar12 + (s32)mem.voidptr;
                        *piVar25 = iVar12;
                        iVar15 = *(s32 *)(iVar12 + 0xc);
                        while( iVar12 != 0 ) {
                            ppiVar13 = (s32 **)(iVar15 + (s32)mem.voidptr);
                            if (iVar15 != 0) {
                                *(s32 ***)(iVar12 + 0xc) = ppiVar13;
                                piVar25 = ppiVar13[1];
                                while( ppiVar13 != NULL ) {
                                    ppNVar11 = __s->mtls;
                                    ppiVar13[1] = (s32 *)ppNVar11[(s32)piVar25];
                                    if (ppiVar13[2] != NULL) {
                                        ppiVar13[2] = (s32 *)((s32)ppiVar13[2] + (s32)mem.voidptr);
                                    }
                                    piVar25 = (s32 *)((s32)ppiVar13[3] + (s32)mem.voidptr);
                                    uVar24 = (u32)(s32)piVar25;
                                    uVar30 = (s32)ppNVar11;
                                    if (ppiVar13[3] != NULL) {
                                        ppiVar13[3] = piVar25;
                                        NuCvtSknInstFix((s32)piVar25);
                                        uVar30 = uVar24;
                                    }
                                    ppiVar14 = (s32 **)((s32)*ppiVar13 + (s32)mem.voidptr);
                                    if (*ppiVar13 != NULL) {
                                        *ppiVar13 = (s32 *)ppiVar14;
                                        ppiVar13 = ppiVar14;
                                    }
                                    else {
                                        ppiVar13 = NULL; 
                                    }
                                    // if (ppiVar13 == NULL) break;
                                    piVar25 = ppiVar13[1];
                                }
                            }
                            iVar15 = *(s32 *)(iVar12 + 0x4c) + (s32)mem.voidptr;
                            if (*(s32 *)(iVar12 + 0x4c) != 0) {
                                
                                *(s32 *)(iVar12 + 0x4c) = iVar15;
                                iVar12 = iVar15;
                            }
                            else {
                                iVar12 = 0;
                            }
                            iVar15 = *(s32 *)(iVar12 + 0xc);
                        }
                    }
                }
            }
            
            pnVar34 = (struct NuGobj *)((s32)&pNVar36->skin_gobj->sysnext + (s32)mem.voidptr);
            if (pNVar36->skin_gobj != NULL) {
                pNVar36->skin_gobj = pnVar34;
                //pNVar16 = pnVar34->geom;
                while( pnVar34 != NULL ) {
                    pnVar32 = (struct NuGeom *)((s32)pnVar34->geom + (s32)mem.voidptr);
                    if (pnVar34->geom != NULL)  {
                        pnVar34->geom = pnVar32;
                        //pNVar17 = pnVar32->mtl;
                        while( pnVar32 != NULL ) {
                            ppNVar11 = __s->mtls;
                            //pnVar32->mtl = ppNVar11[(s32)pNVar17];
                            if (pnVar32->mtl != NULL) {
                                pnVar32->dmastream = ((s32)pnVar32->dmastream * 4) + (s32)mem.voidptr;
                            }
                            
                            if (pnVar32->skindma != NULL) {
                                pnVar32->skindma = (s32)pnVar32->skindma + mem.voidptr;
                                NuCvtSknInstFix(pnVar32->skindma);
                            }
                            
                            if (pnVar32->next != NULL) {
                                pnVar19 = (struct NuGeom *)((s32)pnVar32->next + (s32)mem.voidptr);
                                pnVar32->next = pnVar19;
                                pnVar32 = pnVar19;
                            }
                            else {
                                pnVar32 = NULL;
                            }
                        }
                    }
                    
                    if (pnVar34->next_gobj != NULL) {
                        pnVar20 = (struct NuGobj *)((s32)&pnVar34->next_gobj->sysnext + (s32)mem.voidptr);
                        pnVar34->next_gobj = pnVar20;
                        pnVar34 = pnVar20;
                    }
                    else {
                        pnVar34 = NULL;
                    }
                }
            }
            
            if (pNVar36->blend_gobjs != NULL) {
                ppNVar37 = (struct NuGobj **)((s32)pNVar36->blend_gobjs + (s32)mem.voidptr);
                pNVar36->blend_gobjs = ppNVar37;
                for (iVar33 = 0; iVar33 < (s32)(u32)__s->num_joints; iVar33++) {
                    piVar25 = (s32 *)(ppNVar37[iVar33]);
                    // iVar12 = *piVar25;
                    // iVar33 = iVar33 + 1;
                    if (piVar25 != 0) {
                        iVar12 = iVar12 + (s32)mem.voidptr;
                        *piVar25 = iVar12;
                        // if (iVar12 != 0) {
                            iVar15 = *(s32 *)(iVar12 + 0xc);
                            while( iVar12 != 0 ) {
                                ppiVar13 = (s32 **)(iVar15 + (s32)mem.voidptr);
                                if (iVar15 != 0) {
                                    *(s32 ***)(iVar12 + 0xc) = ppiVar13;
                                    piVar25 = ppiVar13[1];
                                    while( ppiVar13 != NULL ) {
                                        ppNVar11 = __s->mtls;
                                        ppiVar13[1] = (s32 *)ppNVar11[(s32)piVar25];
                                        if (ppiVar13[2] != NULL) {
                                            ppiVar13[2] = (s32 *)((s32)ppiVar13[2] + (s32)mem.voidptr);
                                        }
                                        piVar25 = (s32 *)((s32)ppiVar13[3] + (s32)mem.voidptr);
                                        uVar24 = (u32)(s32)piVar25;
                                        uVar30 = (long)(s32)ppNVar11;
                                        if (ppiVar13[3] != NULL) {
                                            ppiVar13[3] = piVar25;
                                            NuCvtSknInstFix((s32)piVar25);
                                            uVar30 = uVar24;
                                        }
                                        ppiVar14 = (s32 **)((s32)*ppiVar13 + (s32)mem.voidptr);
                                        if (*ppiVar13 != NULL) {
                                            *ppiVar13 = (s32 *)ppiVar14;
                                            ppiVar13 = ppiVar14;
                                        }
                                        else {
                                            ppiVar13 = NULL;
                                        }
                                        // if (ppiVar13 == NULL) break;
                                        piVar25 = ppiVar13[1];
                                    }
                                }
                                
                                iVar15 = *(s32 *)(iVar12 + 0x4c) + (s32)mem.voidptr;
                                if (*(s32 *)(iVar12 + 0x4c) != 0) {
                                    *(s32 *)(iVar12 + 0x4c) = iVar15;
                                    iVar12 = iVar15;
                                }
                                else {
                                    iVar12 = 0;
                                }
                                // if (iVar12 == 0) break;
                                iVar15 = *(s32 *)(iVar12 + 0xc);
                            }
                        // }
                    }
                    iVar12 = iVar33 * 4;
                } 
            }
            
            pnVar34 = (struct NuGobj *)((s32)&pNVar36->blend_skin_gobj->sysnext + (s32)mem.voidptr);
            if (pNVar36->blend_skin_gobj != NULL) {
                pNVar36->blend_skin_gobj = pnVar34;
                //pNVar16 = pnVar34->geom;
                while( pnVar34 != NULL ) {
                    pnVar32 = (struct NuGeom *)((s32)&pnVar34->geom->next + (s32)mem.voidptr);
                    if (pnVar34->geom != NULL)  {
                        pnVar34->geom = pnVar32;
                        while( pnVar32 != NULL ) {
                            ppNVar11 = __s->mtls;
                            pnVar32->mtl = ppNVar11[(s32)pNVar17];
                            if (pnVar32->dmastream != NULL) {
                                pnVar32->dmastream = (s32)pnVar32->dmastream + mem.voidptr;
                            }
                            
                            if (pnVar32->skindma != NULL) {
                                pnVar32->skindma = (s32)pnVar32->skindma + mem.voidptr;
                                NuCvtSknInstFix(pnVar32->skindma);
                            }
                            if (pnVar32->next != NULL) {
                                pnVar19 = (struct NuGeom *)((s32)&pnVar32->next->next + (s32)mem.voidptr);
                                pnVar32->next = pnVar19;
                                pnVar32 = pnVar19;
                            }
                            else {
                                pnVar32 = NULL;
                            }
                        }
                    }
                    
                    if (pnVar34->next_gobj != NULL) {
                        pnVar20 = (struct NuGobj *)((s32)&pnVar34->next_gobj->sysnext + (s32)mem.voidptr);
                        pnVar34->next_gobj = pnVar20;
                        pnVar34 = pnVar20;
                    }
                    else {
                        pnVar34 = NULL;
                    }
                }
            }
            pNVar36 = pNVar36 + 1;
        }

        // memcpy(&__s->sphere_radius, &(pvVar6->max).x, 0x28);
        __s->sphere_radius = pvVar6->sphere_radius;
        __s->sphere_yoff = pvVar6->sphere_yoff;
        //__s->min = pvVar6->field71_0x5c;
        //__s->max = pvVar6->field91_0x70;
        __s->cylinder_yoff = pvVar6->cylinder_yoff;
        __s->cylinder_height = pvVar6->cylinder_height;
        __s->cylinder_radius = pvVar6->cylinder_radius;
    
        if (*(s32 *)&pvVar6->field107_0x80 != 0) {
            pNVar31 = (struct NUCOLLISIONDATA_s *)(*(s32 *)&pvVar6->field107_0x80 + (s32)mem.voidptr);
            __s->collision_data = pNVar31;
            pNVar31->hdrs = (struct NUCOLLISIONHDR_s *)((s32)&pNVar31->hdrs->type + (s32)mem.voidptr);
            for (uVar35 = 0; uVar35 < pNVar31->nitems; uVar35++) {
                pNVar31->hdrs[uVar35].data = (s32)pNVar31->hdrs[uVar35].data + mem.voidptr;
                //pNVar26 = pNVar31->hdrs;
            }
        }
    
        __s->numtexanims = pvVar6->numtexanims;
        __s->texanims = (struct nutexanim_s *)((s32)mem.voidptr + (s32)pvVar6->field119_0x8c);
        // if (0 < iVar8) {
            //pNVar27 = __s->texanims;
            for (iVar33 = 0; iVar33 < __s->numtexanims; iVar33++) {
                iVar8 = iVar33 * 0x20;
                iVar33 = iVar33 + 1;
                lVar23 = 0;
                txanm = ((s32)__s->texanims + iVar8);
                txanm->prev = NULL;
                txanm->tids = (s32)mem.voidptr + txanm->tids;
                txanm->succ = NULL;
                // if (0 < *(short *)(txanm + 3)) {
                    iVar8 = txanm->tids;
                    for (lVar23 = 0; lVar23 < txanm->numtids; lVar23++) {
                        iVar12 = (s32)lVar23;
                        lVar23 = (long)(iVar12 + 1);
                        psVar28 = (short *)(iVar12 * 2 + iVar8);
                        *psVar28 = __s->tids[*psVar28];
                        // if (*(short *)(txanm + 3) <= lVar23) break;
                        iVar8 = txanm->tids;
                    }
                // }
                iVar8 = txanm->scriptname;
                txanm->mtl = __s->mtls[(s32)txanm->mtl];
                txanm->ntaname = txanm->ntaname + (s32)mem.s8;
                txanm->scriptname = iVar8 + mem.s8;
                local_b0 = (union variptr_u *)((u32)((s32)&local_b0->voidptr + 3U) & 0xfffffff0);
                txanm->env = NuTexAnimEnvCreate(local_b0, txanm->mtl, txanm->tids, NuTexAnimProgFind(iVar8 + mem.s8));
                // if (__s->numtexanims <= iVar33) break;
                //pNVar27 = __s->texanims;
            }
        // }
        
        for (iVar8 = 0; iVar8 < __s->numtexanims; iVar8++) {
            iVar33 = iVar8 * 0x20;
            piVar25 = (s32 *)(iVar33 + (s32)__s->texanims);
            *piVar25 = (s32)(piVar25 + 8);
            iVar33 = iVar33 + (s32)__s->texanims;
            *(s32 *)(iVar33 + 0x24) = iVar33;
        }
        NuTexAnimAddList(__s->texanims);
    
        __s->shadow_data = NULL;
        pNVar22 = (struct NUSHADOWDATA_s *)(pvVar6->field59_0x50 + (s32)mem.voidptr);
        
        if ((pvVar6->field59_0x50 != 0)) {
            __s->shadow_data = pNVar22;
            while( pNVar22->joint != 0xff ) {
                
                if (pNVar22->nellipsoids != '\0') {
                    pNVar22->ellipsoids = (struct NUELLIPSOID_s *)((s32)pNVar22->ellipsoids + (s32)mem.voidptr);
                }
                
                if (pNVar22->ncylinders != 0) {
                    pNVar22->cylinders = (struct NUCYLINDER_s *)((s32)pNVar22->cylinders + (s32)mem.intaddr);
                }
                
                if (pNVar22->nshadow_meshes != 0) {
                    pNVar29 = (struct NUSHADOWMESH_s *)((s32)pNVar22->shadow_meshes + (s32)mem.voidptr);
                    pNVar22->shadow_meshes = pNVar29;
                    for (iVar8 = 0; iVar8 < pNVar22->nshadow_meshes; iVar8++) {
                        pNVar29[iVar8].verts = (s32)pNVar29[iVar8].verts + mem.intaddr;
                        pNVar29[iVar8].normals = (s32)pNVar29[iVar8].normals + mem.intaddr;
                    }
                }
                pNVar22 = pNVar22 + 1;
            }
        }
        local_b0 = ALIGN_ADDRESS(buff->voidptr, 0x10U);
        NuDebugMsgProlog("..\\nu2.ps2\\nu3d\\nuhgobj.c", 0x709)("Read %s Used %d bytes", name, (s32)local_b0->intaddr - mem.intaddr);
        buff->voidptr = mem.intaddr;
    }
    return __s;
}


//73.54%

struct nuparamtest_s
{
    s16 unk0;
    u16 unk2;
    s16 unk4;
    s16 unk6;
    u16 unk8;
    u16 unka;
    u8  unkc;
    u8  unkd;
    u8  unke;
    u8  unkf;
    s32 unk10;
    s32 unk14;
    s32 unk18;
    s32 unk1c;
    s16 unk20;
};

struct ps2tex_s { // 0xb0
	/* 0x00 */ struct ps2tex_s *succ;
	/* 0x04 */ struct ps2tex_s *prev;
	/* 0x08 */ short unsigned int lowaddr;
	/* 0x0a */ short unsigned int highaddr;
	/* 0x0c */ short unsigned int req;
	/* 0x0e:0 */ short unsigned int housed : 1;
	/* 0x10 */ short unsigned int p2w;
	/* 0x12 */ short unsigned int p2h;
	/* 0x14 */ struct sceDmaTag *dt_load[7];
	/* 0x30 */ unsigned int loadsize[7];
	/* 0x4c */ unsigned int offset[7];
	/* 0x68 */ short unsigned int loadaddr[7];
	/* 0x76 */ short unsigned int loadwidth[7];
	/* 0x84 */ short unsigned int bltwidth[7];
	/* 0x92 */ unsigned char nummm;
	/* 0x93 */ unsigned char psm;
	/* 0x94 */ unsigned char bltpsm;
	/* 0x95 */ unsigned char tcc;
	/* 0x96 */ unsigned char texa;
	/* 0x97 */ unsigned char tfx;
	/* 0x98 */ struct sceDmaTag *clut_load;
	/* 0x9c */ struct sceDmaTag *clut_alt;
	/* 0xa0 */ short unsigned int clut_addr;
	/* 0xa2 */ short unsigned int clut_width;
	/* 0xa4 */ short unsigned int clut_psm;
	/* 0xa6 */ short unsigned int clut_offset;
	/* 0xa8 */ short unsigned int clut_loadsize;
	/* 0xac */ unsigned int tmpaddr;
};

struct nutex_s { // 0x1c
	/* 0x00 */ enum nutextype_e type;
	/* 0x04 */ s32 width;
	/* 0x08 */ s32 height;
	/* 0x0c */ s32 mmcnt;
	/* 0x10 */ void *bits;
	/* 0x14 */ s32 *pal;
};

struct nusystex_s { // 0xe0
	/* 0x00 */ struct nutex_s tex;
	/* 0x18 */ short int ref;
	/* 0x1a:0 */ short int used : 1;
	/* 0x1a:1 */ short int xdef : 1;
	/* 0x20 */ struct ps2tex_s ps2tex;
};

extern struct nusystex_s * tinfo;
extern s32 tpid;

/*
int NuTexCreateNative( void *data) {
	 int id;
	VARIPTR ptr;
	 NUTEX *tex;
	 PS2TEX *ptex;
	 int n;
	 int id;
}
*/

s32 NuTexCreateNative(struct nuparamtest_s *param_1)
{
    char bVar1;
    u64 uVar2;
    s32 sVar3;
    s32 *piVar4;
    s32 *piVar5;
    s32 iVar6;
    s32 *piVar7;
    s32 *pnVar10;
    struct ps2tex_s *mem;
    struct nusystex_s *tex;
    s32 *pnVar8;
    s32 tids;
    
    iVar6 = tpid;
    tids = tpid;
    while ((tinfo[tpid].ref & 0x10000) != 0) {
        tpid = tids + 1;
        if (iVar6 == tpid) {
            tids = -1;
            goto LAB_0011dde0;
        }
        if (tex_allocmax <= tpid) {
            tpid = 0;
        }
        tids = tpid;
    }
    nutex_alloc_cnt = nutex_alloc_cnt + 1;
    tids = tpid;
    LAB_0011dde0:
    
    if(tids >= 0)
    {
        if (param_1->unk2 == 0) {
            piVar7 = &param_1->unk10;
            tex = &tinfo[tpid];
            // pnVar8 = (int *)(tinfo + tids);
            mem = &tex->ps2tex;
            // tex->ref |= 0x30000;
            tex->ref |= 0x1;
            tex->ref |= 0x2;
           // tex->tex = (struct ps2tex_s*)param_1->unkc;
            tex->tex.width = *(s32*)param_1;
            tex->tex.height = ((s32*)param_1)[1];
            tex->tex.mmcnt = param_1->unke - 1;
            tex->tex.bits = 0;
            tex->tex.pal = 0;
            memset(mem, 0, sizeof(struct ps2tex_s));
            
            mem->nummm = param_1->unke;
            mem->psm = param_1->unkd;
            mem->bltpsm = param_1->unkd;
            mem->tcc = param_1->unkf;
            mem->req = param_1->unk8;
            
            if (tex->tex.type < 4) {
                mem->clut_load = &param_1->unk20;
                mem->clut_offset = *(u16 *)((s32)piVar7 + 4);
                mem->clut_width = *(u16 *)((s32)piVar7 + 8);
                mem->clut_psm = *(u16 *)((s32)piVar7 + 12);
                mem->clut_loadsize = *(u16 *)(&param_1->unk10) - 0x10;
                piVar7 = (int)piVar7 + param_1->unk10;
            }

            piVar5 = tex->ps2tex.bltwidth[2];
            piVar4 = tex->ps2tex.loadsize[1];
            for (iVar6 = 0; iVar6 < param_1->unke; iVar6++) {
                // do {
                    // iVar6 = iVar6 + 1;
                    piVar4[-7] = (int)piVar7 + piVar7[3] + 0x10;
                    piVar4[7] = piVar7[1];
                    *(u16 *)((int)piVar5 + -0xe) = *(u16 *)(piVar7 + 2);
                    *(u16 *)piVar5 = *(u16 *)(piVar7 + 2);
                    piVar5 = (int *)((int)piVar5 + 2);
                    *piVar4 = *piVar7 + -0x10;
                    piVar4 = piVar4 + 1;
                    piVar7 = (int *)((int)piVar7 + *piVar7 + piVar7[3]);
                // } while (iVar6 < (int)(uint)*(u8 *)((int)param_1 + 0xe));
            }
            
            sVar3 = 0;
            for (iVar6 = tex->tex.width; 1 < iVar6; iVar6 = iVar6 >> 1) {
                sVar3 = sVar3 + 1;
            }
            
            mem->p2w = sVar3;
            sVar3 = 0;
            for (iVar6 = tex->tex.height; 1 < iVar6; iVar6 = iVar6 >> 1) {
                sVar3 = sVar3 + 1;
            }
            mem->p2h = sVar3;
        }
        else {
            if (param_1->unk2 != 1) {
                return 0;
            }
            tex = &tinfo[tpid];
            piVar7 = &param_1->unk10;
            // pnVar8 = (int *)(tinfo + tids);
            mem = (void*)&tex->ps2tex;
            // tex->ref |= 0x30000;
            tex->ref |= 0x2;
            tex->ref |= 0x1;
            tex->tex.type = param_1->unkc;
            tex->tex.width = (u16)param_1->unk0;
            tex->tex.height = ((u16*)param_1)[2];
            tex->tex.mmcnt = (param_1->unkf & 0x7F) - 1;
            tex->tex.pal = 0;
            tex->tex.bits = 0;
            memset(mem, 0, sizeof(struct ps2tex_s));
            
            mem->nummm = (param_1->unkf & 0x7F);
            mem->psm = param_1->unkd;
            mem->bltpsm = param_1->unke;
            mem->tcc = ((u32*)param_1)[3] >> 0x1f;
            mem->req = param_1->unk8;

            if (tex->tex.type < 4) {
                mem->clut_load = &param_1->unk20;
                mem->clut_offset = *(u16 *)((s32)piVar7 + 4);
                mem->clut_width = *(u16 *)((s32)piVar7 + 8);
                mem->clut_psm = *(u16 *)((s32)piVar7 + 12);
                mem->clut_loadsize = *(u16 *)((s32)piVar7 + 16) - 0x10;
                piVar7 = (int)piVar7 + param_1->unk10;
            }
            
            piVar5 = (s32)tex + 0xA4;
            piVar4 = (s32)tex + 0x50;
            for (iVar6 = 0; iVar6 < param_1->unke; iVar6++) {
                // do {
                    // iVar6 = iVar6 + 1;
                    piVar4[-7] = (int)piVar7 + piVar7[3] + 0x10;
                    piVar4[7] = piVar7[1];
                    *(u16 *)((int)piVar5 + -0xe) = *(u16 *)(piVar7 + 2);
                    *(u16 *)piVar5 = *(u16 *)(piVar7 + 2);
                    piVar5 = (int *)((int)piVar5 + 2);
                    *piVar4 = *piVar7 + -0x14;
                    piVar4 = piVar4 + 1;
                    piVar7 = (int *)((int)piVar7 + *piVar7 + piVar7[3]);
                // } while (iVar6 < (int)(uint)*(u8 *)((int)param_1 + 0xe));
            }
            
            sVar3 = 0;
            for (iVar6 = tex->tex.width; 1 < iVar6; iVar6 = iVar6 >> 1) {
                sVar3 = sVar3 + 1;
            }
            
            mem->p2w = sVar3;
            sVar3 = 0;
            for (iVar6 = tex->tex.height; 1 < iVar6; iVar6 = iVar6 >> 1) {
                sVar3 = sVar3 + 1;
            }
            mem->p2h = sVar3;
        }
        return tids + 1;
    }
    return 0;
}

s32 NuPs2CreateRenderTarget(struct nutex_s * tex, struct ps2tex_s * ptex);
s32 GenPaletteLoad(struct nutex_s * tex, struct ps2tex_s * ptex);
s32 GenTextureLoad(struct nutex_s * tex, struct ps2tex_s * ptex);
void QuantizeTexture(struct nutex_s *tex);          /* extern */
extern s32 numtl_force_mipmap;
extern s32 nutex_force_quantisation;
extern s32 palcnt;
s32 palette[256];
extern void* txbuff;

/*
	// struct nutex_s *ttex;
	// s32 n;
*/

static inline int NuMiscNextPow2Exp(int v) {
  s32 i;
  s32 rv;
  
  rv = 0;
  if (1 < v) {
    for (i = v; i > 1; i++) {
        rv++;
    }
  }
  if ((v & (1 << (rv)) - 1U) != 0) {
    rv++;
  }
  return rv;
}

s32 NuPs2TxCreate(struct nutex_s *tex, struct ps2tex_s *ptex) 
{
  s32 n;
  struct nutex_s local_60;
  
  switch(tex->type) {
  case NUTEX_RGB16:
  case NUTEX_RGBA16:
  case NUTEX_RGB24:
  case NUTEX_RGBA32:
  case NUTEX_PAL4:
  case NUTEX_PAL8:
  case NUTEX_PAL4_S:
  case NUTEX_PAL8_S:
    break;
  case NUTEX_RT8:
  case NUTEX_RTT8:
  case NUTEX_RT8H:
  case NUTEX_RT32:
  case NUTEX_RT24:
  case NUTEX_RT16:
  case NUTEX_RTT32:
  case NUTEX_RTT24:
  case NUTEX_RTT16:
  case NUTEX_RZT32:
  case NUTEX_RZT24:
  case NUTEX_RZT16:
  //case NUTEX_RTT8H:
  //case NUTEX_RTT16S:
    return NuPs2CreateRenderTarget(tex,ptex);
  default:
    NuErrorProlog("..\\nu2.ps2\\nups2\\ps2txtr.c",0x63d)("unsupported texture format");
    return 0;
  }
  memset(ptex,0,0xb0);
  palcnt = 0;
  if (nutex_force_quantisation != 0) {
    QuantizeTexture(tex);
  }
  if (palcnt != 0) {
    tex->type = NUTEX_PAL8;
      local_60 = *(struct nutex_s *)tex;
    local_60.type = NUTEX_PAL8;
    local_60.pal = &palette;
    local_60.bits = txbuff;
    //local_60 = uVar16;
    NuDebugMsgProlog("..\\nu2.ps2\\nups2\\ps2txtr.c",0x650)("Quantized - %d colours",palcnt);
    tex = &local_60;
  }
    
  ptex->p2w = (short unsigned int)NuMiscNextPow2Exp(tex->width);
  ptex->p2h = (short unsigned int)NuMiscNextPow2Exp(tex->height);
    
  if (tex->width == 0) {
    n = tex->height;
  }
  else {
    if (1 << ((u16)ptex->p2w ) != tex->width) {
      NuDebugMsgProlog("..\\nu2.ps2\\nups2\\ps2txtr.c",0x659)("\r\n*********************************************\r\nTexture width MUST be a power  of two, not %d\r\n*********************************************",tex->width);
    }
    n = tex->height;
  }
  if ((n != 0) && (1 << ((u16)ptex->p2h ) != n)) {
    NuDebugMsgProlog("..\\nu2.ps2\\nups2\\ps2txtr.c",0x65c)("\r\n*********************************************\r\nTexture height MUST be a power of two, not %d\r\n*********************************************"
              ,tex->height);
  }
  ptex->req = 0;
  if (tex->bits != NULL) {
    GenTextureLoad(tex,ptex);
    if (tex->mmcnt == 0) {
        if(numtl_force_mipmap != 0) {
          for (n = 1; n < 0; n++) {
            GenTextureLoad(tex,ptex);
          } 
        }
    }
    for(n = 1; n < tex->mmcnt; n++) {
        GenTextureLoad(tex,ptex);
    }
  }
  GenTextureLoad(tex,ptex);
  GenPaletteLoad(tex,ptex);
    switch (tex->type) {
        case NUTEX_PAL4_S:
        tex->width = tex->width << 1;
        tex->height = tex->height << 2;
        break;
        case NUTEX_PAL8_S:
        tex->width = tex->width << 1;
        tex->height = tex->height << 1;
        break;
    }
  if (ptex->p2w < 0x201) {
    if (0x200 < (u16)ptex->p2h) {
        ptex->p2h = ptex->p2h >> 1;
    }
  }
  else {
    do {
      do {
        ptex->p2w = (ptex->p2w >> 1);
        ptex->p2h = ptex->p2h >> 1;
      } while(ptex->p2w > 0x200); 
    } while(ptex->p2h > 0x200);
  } 
  return 1;
}